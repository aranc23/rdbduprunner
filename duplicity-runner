#! /usr/bin/perl
# Copyright Aran Cox <arancox@gmail.com>

use strict;
use warnings;
use Getopt::Long;
use logentry;
use File::Temp qw( mkdtemp mkstemp );
use Data::Dumper;
use Fcntl qw(:DEFAULT :flock); # import LOCK_* constants
use Env qw( HOME );
use List::Util qw( shuffle );
use Config::General;
use POSIX qw( strftime );

our $TEST=1;
our $VERBOSITY=5;
our $TVERBOSITY=3;
our $LOCALHOST;
our $COMPARE=0;
our $DUPLICITY_BINARY;
our $EXCLUDE_PATH='/etc/rdiff-backup';
our $PATH;
our $HOST;
our $DEST;
our $FORCE=0;
our $REMOVE;
our ($VERBOSE,$DEBUG);
our $AVERAGE;
#our ($IFILES,$IFILESIZE,$DESTSIZECHANGE);
our $LISTOLDEST=0;
our $CHECK=0;
our $CLEANUP=0;
our $DEFMAXINC;
our $DEFMAXAGE;
our $LOCK_FILE="$HOME/duplicity-runner.pid";

our $CONFIG_FILE="$HOME/.duplicity-runner.rc";
our %CONFIG;
our %BACKUPS;
our @INCREMENTS;

our %TSMAP=('s' => 1,
	    'm' => 60,
	    'h' => 60*60,
	    'D' => 60*60*24,
	    'W' => 60*60*24*7,
	    'M' => 60*60*24*30,
	    'Y' => 60*60*24*365,
    );

GetOptions('test!'          => \$TEST,
           'verbosity=i'    => \$VERBOSITY,
           'v|terminal-verbosity=i' => \$TVERBOSITY,
           'localhost=s'    => \$LOCALHOST,
           'duplicity-binary=s' => \$DUPLICITY_BINARY,
           'compare'        => \$COMPARE,
           'path=s'         => \$PATH,
           'host=s'         => \$HOST,
	   'dest=s'         => \$DEST,
           'force!'         => \$FORCE,
           'remove-oldest!' => \$REMOVE,
           'verbose!'       => \$VERBOSE,
           'debug!'         => \$DEBUG,
           'calculate-average' => \$AVERAGE,
	   'list-oldest'    => \$LISTOLDEST,
	   'check'          => \$CHECK, # perform a check-destination-dir on target
	   'config=s'       => \$CONFIG_FILE, # config file
	   'cleanup'        => \$CLEANUP,
	   'maxinc=i'       => \$DEFMAXINC,
	   'maxage=s'       => \$DEFMAXAGE,
	   'lockfile=s'     => \$LOCK_FILE,
          );

if(not defined $LOCALHOST) {
  $LOCALHOST=`hostname`;
  chomp $LOCALHOST;
  my @a=split(/\./,$LOCALHOST);
  @a > 1 and $LOCALHOST=$a[0];
}

logentry::OpenLog('local5','duplcity-runner');
logentry('info','starting');

%CONFIG=new Config::General(-ConfigFile => $CONFIG_FILE,
			    -UseApacheInclude => 1,
			    -AutoTrue => 1,
			    -LowerCaseNames => 1)->getall() or die "unable to parse $CONFIG_FILE";

if(not defined $DUPLICITY_BINARY) {
    if(defined $CONFIG{duplicitybinary}) {
	$DUPLICITY_BINARY=$CONFIG{duplicitybinary};
    } else {
	$DUPLICITY_BINARY='duplicity'; # in our path we hope
    }
}
unless(-x $DUPLICITY_BINARY) {
    logndie("unable to execute $DUPLICITY_BINARY");
}

foreach my $bs (values(%{$CONFIG{backupset}})) {
    unless(defined $$bs{host}) {
	logndie "you must specify a Host directive in each backupset, even if the backup is local";
    }
    my $host=(defined $$bs{host} ? $$bs{host} : $LOCALHOST);
    if(defined $HOST and $host !~ /$HOST/) {
	next;
    }

    my $backupdest;
    if(defined $$bs{backupdestination}) {
	$backupdest=$$bs{backupdestination};
    } elsif(defined $CONFIG{defaultbackupdestination}) {
	$backupdest=$CONFIG{defaultbackupdestination};
    }
    unless(defined $backupdest and defined $CONFIG{backupdestination}{$backupdest}) {
      # can't easily verify the existance of all backup destinations without using duplicity itself
	logndie("no backup root defined: $backupdest".(defined $CONFIG{backupdestination}{$backupdest}{path} ? " ($CONFIG{backupdestination}{$backupdest}{path})" : ''));
    }
    if(defined $DEST and $backupdest !~ /$DEST/) {
	next;
    }
    my $backupdestpath=$CONFIG{backupdestination}{$backupdest}{path};

    foreach my $path (ref($$bs{path}) eq "ARRAY" ? @{$$bs{path}} : ($$bs{path})) {
      if(defined $PATH and $path !~ /$PATH/) {
	  next;
      }
      my $dest;
      my $tag='';
      if(defined $$bs{tag}) {
	  $dest=$$bs{tag};
	  $tag=$dest;
      } else {
	  $dest=$path;
	  $dest =~ s/\//\-/g;
	  $dest =~ s/ /_/g;
	  $dest eq '-' and $dest='-root';
	  $tag=$host.$dest;
      }
      # I should use a perl module here, I guess, not .
      $dest=$backupdestpath.'/'.$tag;
      my @tags=split(/\-/,$tag);

      logentry('debug',"Host: $host Path: $path Tag: $tag Dest: $dest Root: $backupdestpath");

      $BACKUPS{$tag}={%{$bs}}; # very important to make a copy here
      $BACKUPS{$tag}{dest}=$dest;
      $BACKUPS{$tag}{path}=$path;
      $BACKUPS{$tag}{tag}=$tag;
      $BACKUPS{$tag}{host}=$host;
      $BACKUPS{$tag}{backupdestination}=$backupdest;
      $BACKUPS{$tag}{gtag}='generic-'.$tags[1];

      if( -f $EXCLUDE_PATH.'/exclude-generic' ) {
	push(@{$BACKUPS{$tag}{excludes}},$EXCLUDE_PATH.'/exclude-generic');
      } else {
	#logentry('warn',"unable to find the exclude file: ".$EXCLUDE_PATH.'/exclude-'.$BACKUPS{$tag}{gtag}." for backup $tag");
      }

      if( -f $EXCLUDE_PATH.'/exclude-'.$BACKUPS{$tag}{gtag} ) {
	push(@{$BACKUPS{$tag}{excludes}},$EXCLUDE_PATH.'/exclude-'.$BACKUPS{$tag}{gtag});
      } else {
	#logentry('warn',"unable to find the exclude file: ".$EXCLUDE_PATH.'/exclude-'.$BACKUPS{$tag}{gtag}." for backup $tag");
      }

      if( -f $EXCLUDE_PATH.'/exclude-'.$tag ) {
	push(@{$BACKUPS{$tag}{excludes}},$EXCLUDE_PATH.'/exclude-'.$tag);
      } else {
	logentry('warn',"unable to find the exclude file: ".$EXCLUDE_PATH.'/exclude-'.$tag." for backup $tag");
      }
       if(defined $DEFMAXAGE) {
 	  # override!
 	  $BACKUPS{$tag}{maxage}=$DEFMAXAGE;
       } elsif(not defined $BACKUPS{$tag}{maxage} and
 	      defined $CONFIG{maxage}) {
 	  $BACKUPS{$tag}{maxage}=$CONFIG{maxage};
       }
       if(defined $DEFMAXINC) {
 	  # override!
 	  $BACKUPS{$tag}{maxinc}=$DEFMAXINC;
       } elsif(not defined $BACKUPS{$tag}{maxinc} and
 	      defined $CONFIG{maxinc}) {
 	  $BACKUPS{$tag}{maxinc}=$CONFIG{maxinc};
       }
  }
}

if($LISTOLDEST) {
    build_increment_list();
    foreach my $ih (sort { $$a{inctime} <=> $$b{inctime} } (@INCREMENTS)) {
	print localtime($$ih{inctime}).' '.$BACKUPS{$$ih{tag}}{dest}.' '.$$ih{tag}."\n";
    }
} elsif($CLEANUP) {
    foreach my $tag (shuffle(keys(%BACKUPS))) {
	cleanup($tag);
    }
} elsif(defined $REMOVE) {
    build_increment_list();
    remove_oldest('any');
} elsif($CHECK) {
    foreach my $tag (sort backup_sort (keys(%BACKUPS))) {
	my @com=($DUPLICITY_BINARY,
		 '--verbosity',$VERBOSITY,
		 '--terminal-verbosity',$TVERBOSITY,
		 '--check-destination-dir',$BACKUPS{$tag}{dest});
	logentry('info',join(" ",@com));
	unless($TEST) {
	    lock_pid_file();
	    system(@com);
	    unless($? == 0) {
		logentry('err',"unable to execute rdiff-backup!");
	    }
	    unlock_pid_file();
	}
    }
} elsif($AVERAGE) {
    my $avcom="$DUPLICITY_BINARY --calculate-average";
    foreach my $tag (sort backup_sort (keys(%BACKUPS))) {
	my $bh=$BACKUPS{$tag}; # for convenience of typing
	$avcom.=" $BACKUPS{$tag}{dest}/rdiff-backup-data/session_statistics.*.data";
    }
    exec($avcom);
} else { # actually do a backup, please
  BACKUP:
    foreach my $tag (sort backup_sort (keys(%BACKUPS))) {
	my $bh=$BACKUPS{$tag}; # for convenience of typing

	if($$bh{disabled}) {
	    # skip disabled backups
	    next;
	}
	if(defined $CONFIG{$$bh{backupdestination}}{busted} and $CONFIG{$$bh{backupdestination}}{busted}) {
	    next BACKUP;
	}
	unless(-d $CONFIG{backupdestination}{$$bh{backupdestination}}{path}) {
	    $CONFIG{backupdestination}{$$bh{backupdestination}}{busted}=1;
	    logentry('warn',"the backupdestination directory ($BACKUPS{backupdestiantion}{$$bh{backupdestination}}{path}) for $$bh{host}/$$bh{tag} does not exist");
	    logentry('warn',"this warning will only be printed once for each destination");
	    next BACKUP;
	}

	# apply <the hard cleanup rules (maxinc, maxage) before running the backup
	if(-d $$bh{dest}) {
	    # if we haven't run a backup of this dir, don't try to clean it up
	    cleanup($tag);
	}
	# apply constraints before attempting the backup
	while(1) {
	    my $ans=check_space($$bh{backupdestination});
	    if($ans == -1) {
		logentry('err',"unable to determine if this backupdestination ($$bh{backupdestination}:$CONFIG{backupdestination}{$$bh{backupdestination}}{path}) has enough free space");
		logentry('err',"no backups to this backupdestination will be attempted and this message will be repeated only once");
		$CONFIG{$$bh{backupdestination}}{busted}=1;
		next BACKUP;
	    } elsif($ans == 0) {
		unless(remove_oldest($$bh{backupdestination})) {
		    # we failed to remove an increment from the backupdestination
		    # we cannot do backups on this bd for this run!
		    logentry('warn',"unable to remove an increment on backupdestination ($$bh{backupdestination}:$CONFIG{backupdestination}{$$bh{backupdestination}}{path})");
		    logentry('warn',"no further attempts will be made to do backups to this destination");
		    $CONFIG{$$bh{backupdestination}}{busted}=1;
		    next BACKUP;
		}
		# we can just fall out now and let check_space() run again to see if it helped
	    } elsif($ans == 1) {
		# we have enough space to proceed
		last;
	    } else {
		# wtf!
		logndie("check space did not return a valid code (-1,0,1) so we have to die for lack of anything more sensible to do");
	    }
	}
	      
	      
	my @com=($DUPLICITY_BINARY,
		 '--verbosity',$VERBOSITY,
		 '--terminal-verbosity',$TVERBOSITY,
		 '--exclude-special-files',
		 '--exclude-other-filesystems',
	    );
	$VERBOSE and push(@com,'--print-statistics');
	
	if($COMPARE) {
	    push(@com,'--compare');
	}

	foreach my $f (@{$BACKUPS{$tag}{excludes}}) {
	    push(@com,'--exclude-globbing-filelist',
		 $f);
	}
	# this is fugly:
	push(@com,($BACKUPS{$tag}{host} eq $LOCALHOST ? $BACKUPS{$tag}{path} : $BACKUPS{$tag}{host}.'::'.$BACKUPS{$tag}{path}),$BACKUPS{$tag}{dest});

	logentry('info',join(" ",@com));

	unless($TEST) {
	    lock_pid_file();

	    if ($BACKUPS{$tag}{host} ne $LOCALHOST) {
		system("/usr/sbin/fping -q $BACKUPS{$tag}{host}");
		unless($? == 0) {
		    logentry('warning',"fping failed to ping $BACKUPS{$tag}{host}");
		    next;
		}
	    }
	    if (defined $$bh{prerun}) {
		print $$bh{prerun}."\n";
		system($$bh{prerun});
		unless($? == 0) {
		    logentry('err',"unable to execute prerun command: skipping backup!");
		    next;
		}
	    }
	    system(@com);
	    my $mainret=$?;
	    unless($mainret == 0) {
		logentry('err',"unable to execute rdiff-backup!");
	    }
	    if(defined $$bh{postrun}) {
		print $$bh{postrun}."\n";
		system($$bh{postrun});
		unless($? == 0) {
		    logentry('err',"unable to execute postrun command");
		}
		unlock_pid_file();
	    }
	}
    }
}



sub backup_sort {
    my $aprio=(defined $BACKUPS{$a}{priority} ? $BACKUPS{$a}{priority} : 0);
    my $bprio=(defined $BACKUPS{$b}{priority} ? $BACKUPS{$b}{priority} : 0);
    my $ahost=(defined $BACKUPS{$a}{host} ? $BACKUPS{$a}{host} : $LOCALHOST);
    my $bhost=(defined $BACKUPS{$b}{host} ? $BACKUPS{$b}{host} : $LOCALHOST);

    if($aprio == $bprio and $ahost eq $bhost) {
	return $BACKUPS{$a}{path} cmp $BACKUPS{$b}{path};
    } elsif($aprio == $bprio) {
	return $ahost cmp $bhost;
    } # else, compare the prio
    return $aprio <=> $bprio;
}

#sub find_backup_by_tag {
#    foreach my $hr (@BACKUPS) {
#	if

sub lock_pid_file {
    if(defined $LOCK_FILE) {
	# leave it alone
    } elsif(defined $CONFIG{LockFile}) {
	$LOCK_FILE=$CONFIG{LockFile};
    } else {
	$LOCK_FILE="$HOME/rdiff-backup-runner.pid";
    }
    unless(open(LOCK,'+<'.$LOCK_FILE) or open(LOCK,'>'.$LOCK_FILE)) {
	logentry('err',"unable to open pid file: $LOCK_FILE for writing");
	next;
    }
    unless(flock(LOCK,LOCK_EX|LOCK_NB)) {
	logentry('err',"unable to flock the pid file: $LOCK_FILE");
	next;
    }
    truncate(LOCK,0); # this shouldn't fail if we have the file opened and locked!
    print LOCK $$."\n"; # who really cares if this fails?
}

sub unlock_pid_file {
    unlink $LOCK_FILE;
    flock(LOCK,LOCK_UN);
    close LOCK;
}

sub list_increments {
    my $tag=$_[0];

    unless(-d $BACKUPS{$tag}{dest}) {
	# skip non-existant destination directories
	logentry('warn',"non-existant dest dir: $BACKUPS{$tag}{dest}");
	return;
    }
    my $c="$DUPLICITY_BINARY -l --parsable-output ".$BACKUPS{$tag}{dest};
    logentry('debug',$c);
    my @res=`$c`;
    #@res == 1 and next; # if there is only one increment, don't consider it for removal
    foreach my $ln (@res) {
	chomp $ln;
	$ln =~ /^(\d+)\sdirectory$/ or next;
	push(@{$BACKUPS{$tag}{increments}},$1);
    }
}

sub cleanup {
    my $tag=$_[0];
    my @com=($DUPLICITY_BINARY,
	     '--verbosity',$VERBOSITY,
	     '--terminal-verbosity',$TVERBOSITY,
             '--force',
	     '--remove-older-than',
	);
    if(defined $BACKUPS{$tag}{maxinc} and not defined $BACKUPS{$tag}{increments}) {
	list_increments($tag);
    }
    if(defined $BACKUPS{$tag}{maxinc} and
       $BACKUPS{$tag}{maxinc} =~ /^\d+$/ and
       @{$BACKUPS{$tag}{increments}} > $BACKUPS{$tag}{maxinc} ) {
	    # too many!
	    logentry('debug',"$tag\t Incs: ".
		     scalar @{$BACKUPS{$tag}{increments}}.
		     "\t Max: ".$BACKUPS{$tag}{maxinc});
	    my $lastinc=(sort {$a <=> $b} (@{$BACKUPS{$tag}{increments}}))[$BACKUPS{$tag}{maxinc}-1];
	    logentry('debug',"last time to keep for $tag: ".localtime($lastinc));

	    my @icom=(@com,$lastinc);

	    push(@icom,$BACKUPS{$tag}{dest});
	    logentry('info',join(" ",@icom));
	    unless($TEST) {
		system(@icom);
		unless($? == 0) {
		    logentry('err',"unable to execute rdiff-backup!");
		}
	    }
	}
    if(defined $BACKUPS{$tag}{maxage} and
       $BACKUPS{$tag}{maxage} =~ /^\d/) {

	my @icom=(@com,$BACKUPS{$tag}{maxage});
	push(@icom,$BACKUPS{$tag}{dest});

	logentry('info',join(" ",@icom));
	unless($TEST) {
	    system(@icom);
	    unless($? == 0) {
		logentry('err',"unable to execute rdiff-backup!");
	    }
	}
    }
}

sub build_increment_list {
    while(my ($tag,$bp)=each(%BACKUPS)) {
	unless(defined $$bp{increments}) {
	    list_increments($tag);
	}
	foreach my $inctime (@{$$bp{increments}}) {
	    # find various tidbits of info about this increment
	    # /home/spin/rdiff-backup/spidermonk-home-spin-wine-wow/rdiff-backup-data/session_statistics.2008-02-22T03:05:48-06:00.data
	    my @d=localtime($inctime);
	    my $rbdate=strftime("%FT%T",@d);
	    my $glob="$$bp{dest}/rdiff-backup-data/session_statistics.$rbdate*.data";
	    my $ssdfile=(glob($glob))[0];
	    my $data={}; # store info from the session stats file... which we never ever ever use!
	    
	    if(defined $ssdfile) {
		if(open(SSD,$ssdfile)) {
		    foreach my $ln (<SSD>) {
			$ln =~ /^(\w+)\s+(\d+\.?\d*)/ and $$data{$1}=$2;
		    }
		    close(SSD);
		} else {
		    logentry('err',"unable to open increment file: $glob $ssdfile");
		}
	    } else {
		logentry('notice',"unable to find the session statistics file for this increment: $tag $rbdate using glob: $glob");
	    }

	    push(@INCREMENTS,{ inctime => $inctime,
			       incdt => [@d],
			       ssdfile => $ssdfile,
			       ssddata => $data,
			       tag     => $tag,
			       backupdestination => $$bp{backupdestination},
		 }
		);
	}
    }
    #print Dumper \@INCREMENTS;
}

sub remove_oldest {
    my $backupdest=$_[0];

    unless(@INCREMENTS > 0) {
	build_increment_list();
    }
    foreach my $ih (sort { $$a{inctime} <=> $$b{inctime} } (@INCREMENTS)) {
	logentry('debug',"remove_oldest: $$ih{inctime}");
	if(defined $$ih{removed} and $$ih{removed}) {
	    logentry('debug',"cannot remove previously removed increment for $$ih{tag}");
	    next;
	}
	if(scalar @{$BACKUPS{$$ih{tag}}{increments}} == 1) {
	    # cannot remove the only increment!
	    logentry('debug',"cannot remove only increment for $$ih{tag}");
	    next;
	}
	unless($backupdest eq 'any' or
	       $backupdest eq $BACKUPS{$$ih{tag}}{backupdestination}) {
	    logentry('debug',"skipping because it isn't in the backupdestination we are looking for: $backupdest $BACKUPS{$$ih{tag}}{backupdestination}");
	    next;
	}
	my $t=$$ih{inctime};
	my @com=($DUPLICITY_BINARY,
		 '--verbosity',$VERBOSITY,
		 '--terminal-verbosity',$TVERBOSITY,
		 '--remove-older-than',($t+1), # do I really need to add 1?
		 $BACKUPS{$$ih{tag}}{dest});
	logentry('info',join(" ",@com));
	unless($TEST) {
	    system(@com);
	    unless($? == 0) {
		logentry('err',"rdiff-backup did not exit cleanly!");
		return 0;
	    }
	}
	$$ih{removed}=1;
#	print Dumper $BACKUPS{$$ih{tag}}{increments};
	shift(@{$BACKUPS{$$ih{tag}}{increments}});
#	print Dumper $BACKUPS{$$ih{tag}}{increments};
	return 1;
    }
}

sub check_space {
    my $bh=$CONFIG{backupdestination}{$_[0]};
    update_bd_space($bh) or return -1;    
    if(defined $$bh{minfree} and $$bh{avail} < $$bh{minfree}) {
	return 0;
    } elsif(defined $$bh{percentused} and $$bh{percent} > $$bh{percentused}) {
	return 0;
    }
    return 1;
}

sub update_bd_space {
    my $bh=$_[0];
    my $com="df -vP $$bh{path}";
    my @a=`$com`;
    unless($? == 0) {
	logentry('err',"unable to run \"$com\": no further backups will be attempted to this directory");
	$$bh{busted}=1;
	return 0;
    }
    unless($a[1] =~ /(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\%/) {
	logentry('err',"unable to parse output from \"$com\": no further backups will be attempted to this directory");
	$$bh{busted}=1;
	return 0;
    }
    $$bh{size}=$1;
    $$bh{used}=$2;
    $$bh{avail}=$3;
    $$bh{percent}=$4;
    return 1;
}

# TODO:
# --check is broken
# --clean --maxage X should probably be --remove-older-than  and --clean --maxinc X should maybe be --remove-more-than?
# this TODO list makes no sense and is probably also broken
# add some pod?
# --force should do something or be removed...
