#! /usr/bin/perl
# Copyright Aran Cox <arancox@gmail.com>

use strict;
use warnings;
use Getopt::Long;
use logentry;
use File::Temp qw( mkdtemp mkstemp );
use Data::Dumper;
use Fcntl qw(:DEFAULT :flock); # import LOCK_* constants
use Env qw( HOME );
use List::Util qw( shuffle );
use Config::General;
use POSIX qw( strftime );

our $TEST=1;
our $VERBOSITY=5;
our $LOCALHOST;
our $COMPARE=0;
our $DUPLICITY_BINARY;
our $EXCLUDE_PATH='/etc/rdiff-backup';
our $PATH;
our $DEST;
our $FORCE=0;
our ($VERBOSE,$DEBUG);
our $AVERAGE;
#our ($IFILES,$IFILESIZE,$DESTSIZECHANGE);
our $CHECK=0;
our $CLEANUP=0;
our $DEFMAXINC;
our $DEFMAXAGE;
our $LOCK_FILE="$HOME/duplicity-runner.pid";

our $CONFIG_FILE="$HOME/.duplicity-runner.rc";
our %CONFIG;
our %BACKUPS;
our @INCREMENTS;

our %TSMAP=('s' => 1,
	    'm' => 60,
	    'h' => 60*60,
	    'D' => 60*60*24,
	    'W' => 60*60*24*7,
	    'M' => 60*60*24*30,
	    'Y' => 60*60*24*365,
    );

GetOptions('test!'          => \$TEST,
           'verbosity=i'    => \$VERBOSITY,
           'localhost=s'    => \$LOCALHOST,
           'duplicity-binary=s' => \$DUPLICITY_BINARY,
           'compare'        => \$COMPARE,
           'path=s'         => \$PATH,
	   'dest=s'         => \$DEST,
           'force!'         => \$FORCE,
           'verbose!'       => \$VERBOSE,
           'debug!'         => \$DEBUG,
           'calculate-average' => \$AVERAGE,
	   'check'          => \$CHECK, # perform a check-destination-dir on target
	   'config=s'       => \$CONFIG_FILE, # config file
	   'cleanup'        => \$CLEANUP,
	   'maxinc=i'       => \$DEFMAXINC,
	   'maxage=s'       => \$DEFMAXAGE,
	   'lockfile=s'     => \$LOCK_FILE,
          );

if(not defined $LOCALHOST) {
  if(defined $CONFIG{localhost}) {
    $LOCALHOST=$CONFIG{localhost};
  } else {
    $LOCALHOST=`hostname`;
    chomp $LOCALHOST;
    my @a=split(/\./,$LOCALHOST);
    @a > 1 and $LOCALHOST=$a[0];
  }
}

logentry::OpenLog('local5','duplcity-runner');
logentry('info','starting');

%CONFIG=new Config::General(-ConfigFile => $CONFIG_FILE,
			    -UseApacheInclude => 1,
			    -AutoTrue => 1,
			    -LowerCaseNames => 1)->getall() or die "unable to parse $CONFIG_FILE";

if(not defined $DUPLICITY_BINARY) {
    if(defined $CONFIG{duplicitybinary}) {
	$DUPLICITY_BINARY=$CONFIG{duplicitybinary};
    } else {
	$DUPLICITY_BINARY='duplicity'; # in our path we hope
    }
}
unless(-x $DUPLICITY_BINARY) {
    logndie("unable to execute $DUPLICITY_BINARY");
}

# grab more stuff from the config and put them into ENV for use by duplicity
if(defined $CONFIG{gpgpassphrase}) {
  $ENV{PASSPHRASE}=$CONFIG{gpgpassphrase};
}
if(defined $CONFIG{awsaccesskeyid}) {
  $ENV{AWS_ACCESS_KEY_ID}=$CONFIG{awsaccesskeyid};
}
if(defined $CONFIG{awssecretaccesskey}) {
  $ENV{AWS_SECRET_ACCESS_KEY}=$CONFIG{awssecretaccesskey};
}


foreach my $bs (values(%{$CONFIG{backupset}})) {
  my $host=$LOCALHOST;

    my $backupdest;
    if(defined $$bs{backupdestination}) {
	$backupdest=$$bs{backupdestination};
    } elsif(defined $CONFIG{defaultbackupdestination}) {
	$backupdest=$CONFIG{defaultbackupdestination};
    }
    unless(defined $backupdest and defined $CONFIG{backupdestination}{$backupdest}) {
      # can't easily verify the existance of all backup destinations without using duplicity itself
	logndie("no backup root defined: $backupdest".(defined $CONFIG{backupdestination}{$backupdest}{path} ? " ($CONFIG{backupdestination}{$backupdest}{path})" : ''));
    }
    if(defined $DEST and $backupdest !~ /$DEST/) {
	next;
    }
    my $backupdestpath=$CONFIG{backupdestination}{$backupdest}{path};

    foreach my $path (ref($$bs{path}) eq "ARRAY" ? @{$$bs{path}} : ($$bs{path})) {
      if(defined $PATH and $path !~ /$PATH/) {
	  next;
      }
      my $dest;
      my $tag='';
      if(defined $$bs{tag}) {
	  $dest=$$bs{tag};
	  $tag=$dest;
      } else {
	  $dest=$path;
	  $dest =~ s/\//\-/g;
	  $dest =~ s/ /_/g;
	  $dest eq '-' and $dest='-root';
	  $tag=$host.$dest;
      }
      # I should use a perl module here, I guess, not .
      $dest=$backupdestpath.'/'.$tag;
      my @tags=split(/\-/,$tag);

      logentry('debug',"Host: $host Path: $path Tag: $tag Dest: $dest Root: $backupdestpath");

      $BACKUPS{$tag}={%{$bs}}; # very important to make a copy here
      $BACKUPS{$tag}{dest}=$dest;
      $BACKUPS{$tag}{path}=$path;
      $BACKUPS{$tag}{tag}=$tag;
      $BACKUPS{$tag}{host}=$host;
      $BACKUPS{$tag}{backupdestination}=$backupdest;
      $BACKUPS{$tag}{gtag}='generic-'.$tags[1];

      if( -f $EXCLUDE_PATH.'/exclude-generic' ) {
	push(@{$BACKUPS{$tag}{excludes}},$EXCLUDE_PATH.'/exclude-generic');
      } else {
	#logentry('warn',"unable to find the exclude file: ".$EXCLUDE_PATH.'/exclude-'.$BACKUPS{$tag}{gtag}." for backup $tag");
      }

      if( -f $EXCLUDE_PATH.'/exclude-'.$BACKUPS{$tag}{gtag} ) {
	push(@{$BACKUPS{$tag}{excludes}},$EXCLUDE_PATH.'/exclude-'.$BACKUPS{$tag}{gtag});
      } else {
	#logentry('warn',"unable to find the exclude file: ".$EXCLUDE_PATH.'/exclude-'.$BACKUPS{$tag}{gtag}." for backup $tag");
      }

      if( -f $EXCLUDE_PATH.'/exclude-'.$tag ) {
	push(@{$BACKUPS{$tag}{excludes}},$EXCLUDE_PATH.'/exclude-'.$tag);
      } else {
	logentry('warn',"unable to find the exclude file: ".$EXCLUDE_PATH.'/exclude-'.$tag." for backup $tag");
      }
       if(defined $DEFMAXAGE) {
 	  # override!
 	  $BACKUPS{$tag}{maxage}=$DEFMAXAGE;
       } elsif(not defined $BACKUPS{$tag}{maxage} and
 	      defined $CONFIG{maxage}) {
 	  $BACKUPS{$tag}{maxage}=$CONFIG{maxage};
       }
       if(defined $DEFMAXINC) {
 	  # override!
 	  $BACKUPS{$tag}{maxinc}=$DEFMAXINC;
       } elsif(not defined $BACKUPS{$tag}{maxinc} and
 	      defined $CONFIG{maxinc}) {
 	  $BACKUPS{$tag}{maxinc}=$CONFIG{maxinc};
       }
  }
}

if($CLEANUP) {
    # since duplicity has a cleanup command, so this shall stay for now
    foreach my $tag (shuffle(keys(%BACKUPS))) {
	cleanup($tag);
    }
} elsif($CHECK) {
    # since duplicity has a check command, so this shall stay for now
    foreach my $tag (sort backup_sort (keys(%BACKUPS))) {
	my @com=($DUPLICITY_BINARY,
		 '--verbosity',$VERBOSITY,
		 '--check-destination-dir',$BACKUPS{$tag}{dest});
	logentry('info',join(" ",@com));
	unless($TEST) {
	    lock_pid_file();
	    system(@com);
	    unless($? == 0) {
		logentry('err',"unable to execute rdiff-backup!");
	    }
	    unlock_pid_file();
	}
    }
} else { # actually do a backup, please
  BACKUP:
    foreach my $tag (sort backup_sort (keys(%BACKUPS))) {
	my $bh=$BACKUPS{$tag}; # for convenience of typing

	if($$bh{disabled}) {
	    # skip disabled backups
	    next;
	}

	if(not -d $BACKUPS{$tag}{path}) {
	  logentry('warn',"backup path $BACKUPS{$tag}{path} does not exist: skipping this backup");
	  next BACKUP;
	}

	if(defined $CONFIG{$$bh{backupdestination}}{busted} and $CONFIG{$$bh{backupdestination}}{busted}) {
	    next BACKUP;
	}

	my @com=($DUPLICITY_BINARY,
		 '--verbosity',$VERBOSITY,
		 '--exclude-other-filesystems',
	    );
	if(defined $CONFIG{signkey}) {
	  push(@com,'--sign-key',$CONFIG{signkey});
	}
	if(defined $CONFIG{encryptkey}) {
	  push(@com,'--encrypt-key',$CONFIG{encryptkey});
	}

	not $VERBOSE and push(@com,'--no-print-statistics');

	# if($COMPARE) {
	#     push(@com,'--compare');
	# }

	foreach my $f (@{$BACKUPS{$tag}{excludes}}) {
	    push(@com,'--exclude-globbing-filelist',
		 $f);
	}
	# this is fugly:
	push(@com,$BACKUPS{$tag}{path},$BACKUPS{$tag}{dest});

	logentry('info',join(" ",@com));

	unless($TEST) {
	    lock_pid_file();

	    if (defined $$bh{prerun}) {
		print $$bh{prerun}."\n";
		system($$bh{prerun});
		unless($? == 0) {
		    logentry('err',"unable to execute prerun command: skipping backup!");
		    next;
		}
	    }
	    system(@com);
	    my $mainret=$?;
	    unless($mainret == 0) {
		logentry('err',"unable to execute rdiff-backup!");
	    }
	    if(defined $$bh{postrun}) {
		print $$bh{postrun}."\n";
		system($$bh{postrun});
		unless($? == 0) {
		    logentry('err',"unable to execute postrun command");
		}
		unlock_pid_file();
	    }
	}
    }
}



sub backup_sort {
    my $aprio=(defined $BACKUPS{$a}{priority} ? $BACKUPS{$a}{priority} : 0);
    my $bprio=(defined $BACKUPS{$b}{priority} ? $BACKUPS{$b}{priority} : 0);
    
    return $aprio <=> $bprio;
}

#sub find_backup_by_tag {
#    foreach my $hr (@BACKUPS) {
#	if

sub lock_pid_file {
    if(defined $LOCK_FILE) {
	# leave it alone
    } elsif(defined $CONFIG{LockFile}) {
	$LOCK_FILE=$CONFIG{LockFile};
    } else {
	$LOCK_FILE="$HOME/rdiff-backup-runner.pid";
    }
    unless(open(LOCK,'+<'.$LOCK_FILE) or open(LOCK,'>'.$LOCK_FILE)) {
	logentry('err',"unable to open pid file: $LOCK_FILE for writing");
	next;
    }
    unless(flock(LOCK,LOCK_EX|LOCK_NB)) {
	logentry('err',"unable to flock the pid file: $LOCK_FILE");
	next;
    }
    truncate(LOCK,0); # this shouldn't fail if we have the file opened and locked!
    print LOCK $$."\n"; # who really cares if this fails?
}

sub unlock_pid_file {
    unlink $LOCK_FILE;
    flock(LOCK,LOCK_UN);
    close LOCK;
}

sub cleanup {
    my $tag=$_[0];
    my @com=($DUPLICITY_BINARY,
	     '--verbosity',$VERBOSITY,
             '--force',
	     '--remove-older-than',
	);
    if(defined $BACKUPS{$tag}{maxinc} and not defined $BACKUPS{$tag}{increments}) {
	list_increments($tag);
    }
    if(defined $BACKUPS{$tag}{maxinc} and
       $BACKUPS{$tag}{maxinc} =~ /^\d+$/ and
       @{$BACKUPS{$tag}{increments}} > $BACKUPS{$tag}{maxinc} ) {
	    # too many!
	    logentry('debug',"$tag\t Incs: ".
		     scalar @{$BACKUPS{$tag}{increments}}.
		     "\t Max: ".$BACKUPS{$tag}{maxinc});
	    my $lastinc=(sort {$a <=> $b} (@{$BACKUPS{$tag}{increments}}))[$BACKUPS{$tag}{maxinc}-1];
	    logentry('debug',"last time to keep for $tag: ".localtime($lastinc));

	    my @icom=(@com,$lastinc);

	    push(@icom,$BACKUPS{$tag}{dest});
	    logentry('info',join(" ",@icom));
	    unless($TEST) {
		system(@icom);
		unless($? == 0) {
		    logentry('err',"unable to execute rdiff-backup!");
		}
	    }
	}
    if(defined $BACKUPS{$tag}{maxage} and
       $BACKUPS{$tag}{maxage} =~ /^\d/) {

	my @icom=(@com,$BACKUPS{$tag}{maxage});
	push(@icom,$BACKUPS{$tag}{dest});

	logentry('info',join(" ",@icom));
	unless($TEST) {
	    system(@icom);
	    unless($? == 0) {
		logentry('err',"unable to execute rdiff-backup!");
	    }
	}
    }
}

