#! /usr/bin/perl
# Copyright Aran Cox <arancox@gmail.com>

use strict;
use warnings;

#from a standard perl distribution, on UNIX at least
use Getopt::Long;
use Fcntl qw(:DEFAULT :flock); # import LOCK_* constants
use Env qw( HOME USER );
use Data::Dumper;
use POSIX qw( strftime );

# added from CPAN or system packages
use Config::General;
use Log::Dispatch;
use Log::Dispatch::Syslog;
use Log::Dispatch::Screen;
use Log::Dispatch::File;

# can be overridden from the command line, but not the config
our $CONFIG_FILE="$HOME/.rdbduprunner.rc";

# these are command line options, and in some cases config file options
# the following changes the major mode of operation for rdbduprunner:
our $AVERAGE=0;
our $CLEANUP=0;
our $COMPARE=0;
our $DUMP=0;
our $LISTOLDEST=0;
our $REMOVE=0;
our $STATUS=0;
our $TIDY=0;
our $LIST=0;
# the following affect what options are passed to rdiff-backup and/or duplicity
our $FORCE=0;
our $FULL=0;
our $MAXAGE;
our $MAXINC;
our $STATS=1;
our $VERBOSITY;
our $TVERBOSITY;
our $USEAGENT;
our $ALLOWSOURCEMISMATCH=0;
our $TEMPDIR;
# the next three options limit which backups get acted upon
our $DEST;
our $HOST;
our $PATH;
# configuring rdbduprunner:
our $DUPLICITY_BINARY;
our $RDIFF_BACKUP_BINARY;
our $RSYNC_BINARY;
our $EXCLUDE_PATH;
our $FACILITY='user';
our $LOG_LEVEL='info';
our $LOCALHOST;
our $LOCK_FILE;
our $LOG_FILE=($USER eq 'root' ? '/var/log/rdbduprunner.log' : $HOME.'/var/log/rdbduprunner.log');
our $TEST=1;

# global variables
our %CONFIG;
our @BACKUPS;
our $DISPATCHER;
our @INCREMENTS;

GetOptions(
           # can be overridden from the command line, but not the config
           'config=s'       => \$CONFIG_FILE, # config file

           # the following changes the major mode of operation for rdbduprunner:
           'calculate-average'      => \$AVERAGE,
           'cleanup'                => \$CLEANUP,
           'check'                  => \$CLEANUP,
	   'compare'                => \$COMPARE,
           'verify'                 => \$COMPARE,
           'dump'                   => \$DUMP,
           'list-oldest'            => \$LISTOLDEST,
           'remove-oldest'          => \$REMOVE,
           'status'                 => \$STATUS,
           'tidy'                   => \$TIDY,
           'list'                   => \$LIST,

           # the following affect what options are passed to rdiff-backup and/or duplicity
           'force!'                 => \$FORCE,
           'full'                   => \$FULL,
           'maxage=s'               => \$MAXAGE,
           'maxinc=s'               => \$MAXINC,
           'stats!'                 => \$STATS,
           'v|verbosity=i'          => \$VERBOSITY,
           't|terminal-verbosity=i' => \$TVERBOSITY,
           'u|use-agent!'            => \$USEAGENT,
	   'allow-source-mismatch!' => \$ALLOWSOURCEMISMATCH,
           'tempdir=s'              => \$TEMPDIR,

           # the next three options limit which backups get acted upon
           'dest=s'                 => \$DEST,
           'host=s'                 => \$HOST,
           'path=s'                 => \$PATH,

           # configuring rdbduprunner:
           'duplicity-binary=s'     => \$DUPLICITY_BINARY,
           'rdiff-backup-binary=s'  => \$RDIFF_BACKUP_BINARY,
           'rsync-binary=s'         => \$RSYNC_BINARY,
           'exclude-path=s'         => \$EXCLUDE_PATH,
           'facility=s'             => \$FACILITY,
           'level=s'                => \$LOG_LEVEL,
           'localhost=s'            => \$LOCALHOST,
           'lockfile=s'             => \$LOCK_FILE,
           'logfile=s'              => \$LOG_FILE,
           'test!'                  => \$TEST,
          );

if(not defined $LOCALHOST) {
  if(defined $CONFIG{localhost}) {
    $LOCALHOST=$CONFIG{localhost};
  } else {
    $LOCALHOST=`hostname`;
    chomp $LOCALHOST;
    my @a=split(/\./,$LOCALHOST);
    @a > 1 and $LOCALHOST=$a[0];
  }
}

my $callback_clean = sub { my %t=@_;
                           chomp $t{message};
                           return $t{message}."\n"; # add a newline
                         };

create_dispatcher();
info('starting');

%CONFIG=new Config::General(-ConfigFile => $CONFIG_FILE,
			    -IncludeGlob => 1,
			    -AutoTrue => 1,
			    -LowerCaseNames => 1)->getall() or die "unable to parse $CONFIG_FILE";

if(not defined $DUPLICITY_BINARY) {
    if(defined $CONFIG{duplicitybinary}) {
	$DUPLICITY_BINARY=$CONFIG{duplicitybinary};
    } else {
	$DUPLICITY_BINARY='duplicity'; # in our path we hope
    }
}

if(not defined $RDIFF_BACKUP_BINARY) {
    if(defined $CONFIG{rdiffbackupbinary}) {
	$RDIFF_BACKUP_BINARY=$CONFIG{rdiffbackupbinary};
    } else {
	$RDIFF_BACKUP_BINARY='rdiff-backup'; # in our path we hope
    }
}

if(not defined $RSYNC_BINARY) {
  if(defined $CONFIG{rsyncbinary}) {
	$RSYNC_BINARY=$CONFIG{rsyncbinary};
  } else {
	$RSYNC_BINARY='rsync'; # in our path we hope
  }
}

unless(defined $VERBOSITY) { # from the command line
  if(defined $CONFIG{verbosity}) {
    $VERBOSITY=$CONFIG{verbosity};
  }
}

unless(defined $TVERBOSITY) { # from the command line
  if(defined $CONFIG{terminalverbosity}) {
    $TVERBOSITY=$CONFIG{terminalverbosity};
  }
}

if(defined $LOCK_FILE) {
  # leave it alone, it comes from the command line
} elsif(defined $CONFIG{lockfile}) {
  $LOCK_FILE=$CONFIG{lockfile};
} else {
  $LOCK_FILE="$HOME/rdbduprunner.pid";
}

if(defined $EXCLUDE_PATH) {
  # leave it alone, it comes from the command line
} elsif(defined $CONFIG{excludepath}) {
  $EXCLUDE_PATH=$CONFIG{excludepath};
} else {
  $EXCLUDE_PATH='/etc/rdbduprunner-excludes';
}

if(not defined $USEAGENT) {
  if(defined $CONFIG{useagent}) {
    $USEAGENT=1;
  } else {
    $USEAGENT=0;
  }
}

if(not defined $TEMPDIR) {
  if(defined $CONFIG{tempdir}) {
    $TEMPDIR=$CONFIG{tempdir};
  }
}

foreach my $bstag (keys(%{$CONFIG{backupset}})) {
    my $bs=$CONFIG{backupset}{$bstag};
    my $host=(defined $$bs{host} ? $$bs{host} : $LOCALHOST);
    my $btype;
    my $backupdest;

    if(defined $HOST and $host !~ /$HOST/) {
      next;
    }

    if(defined $$bs{backupdestination}) {
        $backupdest=$$bs{backupdestination};
    } elsif(defined $CONFIG{defaultbackupdestination}) {
        $backupdest=$CONFIG{defaultbackupdestination};
    }
    unless(defined $backupdest) {
        error("there is no BackupDestination defined for the BackupSet ($bstag): so it cannot be processed");
        next;
    }
    if(defined $CONFIG{backupdestination}{$backupdest}{type} and
           $CONFIG{backupdestination}{$backupdest}{type} =~ /^(rdiff\-backup|duplicity|rsync)$/) {
      # check to make sure that if the type isn't set, we set it to duplicity
      $btype=$CONFIG{backupdestination}{$backupdest}{type};
    } else {
      $btype='duplicity';
    }
    if($btype eq 'duplicity' and $host ne $LOCALHOST) {
      error("$bstag is a duplicity backup with host set to $host: duplicity backups must have a local source!");
      next;
    }

    if(defined $DEST and $backupdest !~ /$DEST/) {
        next;
    }
    my $backupdestpath=$CONFIG{backupdestination}{$backupdest}{path};

    foreach my $path (ref($$bs{path}) eq "ARRAY" ? @{$$bs{path}} : ($$bs{path})) {
        $path =~ s/.+\/$//; # remove any trailing slash, but only if there is something before it!
        my $bh={};
        if(defined $PATH and $path !~ /$PATH/) {
            next;
        }
        my $dest;
        my $tag='';
        if(defined $$bs{tag}) {
            $dest=$$bs{tag};
            $tag=$dest;
        } else {
            $dest=$path;
            $dest =~ s/\//\-/g;
            $dest =~ s/ /_/g;
            $dest eq '-' and $dest='-root';
            $tag=$host.$dest;
        }
        # I should use a perl module here, I guess, not .
        $dest=$backupdestpath.'/'.$tag;
        my @tags=split(/\-/,$tag);

        debug("Host: $host Path: $path Tag: $tag Dest: $dest Root: $backupdestpath");

        $bh={%{$bs}}; # very important to make a copy here
        $$bh{dest}=$dest;
        $$bh{path}=$path;
        $$bh{tag}=$tag;
        $$bh{host}=$host;
        $$bh{backupdestination}=$backupdest;
        $$bh{gtag}='generic-'.$tags[1];
        $$bh{btype}=$btype;
        if($$bh{btype} eq 'rsync') {
          $$bh{path}=$$bh{path}.'/';
        }
        if( -f $EXCLUDE_PATH.'/exclude-generic' ) {
            push(@{$$bh{excludes}},$EXCLUDE_PATH.'/exclude-generic');
        }

        if( -f $EXCLUDE_PATH.'/exclude-'.$$bh{gtag} ) {
            push(@{$$bh{excludes}},$EXCLUDE_PATH.'/exclude-'.$$bh{gtag});
        }

        if( -f $EXCLUDE_PATH.'/exclude-'.$tag ) {
            push(@{$$bh{excludes}},$EXCLUDE_PATH.'/exclude-'.$tag);
        } else {
            warning("unable to find the exclude file: ".$EXCLUDE_PATH.'/exclude-'.$tag." for backup $tag");
        }

        if(defined $MAXAGE) {
            $$bh{maxage}=$MAXAGE;
        } elsif(not defined $$bh{maxage} and
                defined $CONFIG{maxage}) {
            $$bh{maxage}=$CONFIG{maxage};
        }
        if(defined $MAXINC) {
            $$bh{maxinc}=$MAXINC;
        } elsif(not defined $$bh{maxinc} and
                defined $CONFIG{maxinc}) {
            $$bh{maxinc}=$CONFIG{maxinc};
        }
        # if this is defined in a backupset, allow that to override the global definition, if it exists
        foreach my $var (sort(map(lc,qw( GPGPassPhrase AWSAccessKeyID AWSSecretAccessKey SignKey EncryptKey Trickle )))) {
            unless(defined $$bh{$var}) {
                if(defined $CONFIG{$var}) {
                    $$bh{$var}=$CONFIG{$var};
                }
                if(defined $CONFIG{backupdestination}{$$bh{backupdestination}}{$var}) {
                    # the above is why people hate perl, possibly
                    $$bh{$var}=$CONFIG{backupdestination}{$$bh{backupdestination}}{$var};
                }
            }
        }
        push(@BACKUPS,$bh);
    }
}

if($DUMP) {
  print Dumper \%CONFIG;
  print Dumper \@BACKUPS;
  notice("you asked me to dump and exit!");
  exit(0);
}

if($STATUS) {
  foreach my $bh (sort backup_sort (@BACKUPS)) {
    my @com;
    if($$bh{btype} eq 'duplicity') {
      @com=($DUPLICITY_BINARY,'collection-status');
      $USEAGENT and push(@com,'--use-agent');
    } elsif($$bh{btype} eq 'rdiff-backup') {
      @com=($RDIFF_BACKUP_BINARY,'-l');
    } elsif($$bh{btype} eq 'rsync') {
      @com=('du','-cshx');
    }
    unless($$bh{btype} eq 'rsync') {
      push(@com,verbargs($bh));

    }
    push(@com,$$bh{dest});
    info(join(" ",@com));
    unless($TEST) {
      lock_pid_file();
      set_env($bh);
      system(@com);
      unless($? == 0) {
        error('unable to execute '.$com[0].'!');
      }
      unlock_pid_file();
    }
  }
} elsif($LISTOLDEST) {
    build_increment_list();
    foreach my $ih (sort { $$a{inctime} <=> $$b{inctime} } (@INCREMENTS)) {
        print localtime($$ih{inctime}).' '.$$ih{bh}{dest}.' '.$$ih{tag}."\n";
    }
} elsif($REMOVE) {
    build_increment_list();
    remove_oldest('any');
} elsif($CLEANUP) {
    foreach my $bh (sort backup_sort (@BACKUPS)) {
        my @com;
        if($$bh{btype} eq 'duplicity') {
            push(@com,$DUPLICITY_BINARY,'cleanup');
            $USEAGENT and push(@com,'--use-agent');
            if($FORCE) {
                push(@com,'--force');
            }
        } elsif($$bh{btype} eq 'rdiff-backup') {
            push(@com,$RDIFF_BACKUP_BINARY,'--check-destination-dir');
        }
        push(@com,verbargs($bh),
             $$bh{dest});
        info(join(" ",@com));
        unless($TEST) {
            lock_pid_file();
            set_env($bh);
            system(@com);
            unless($? == 0) {
                error("unable to execute $$bh{btype}!");
            }
            unlock_pid_file();
        }
    }
} elsif ($TIDY) {
    foreach my $bh (sort backup_sort (@BACKUPS)) {
      unless($TEST) {
	lock_pid_file();
      }
        tidy($bh);
      unless($TEST) {
	unlock_pid_file();
      }
    }
} elsif($AVERAGE) {
    my $avcom="$RDIFF_BACKUP_BINARY --calculate-average";
    foreach my $bh (sort backup_sort (@BACKUPS)) {
        unless($$bh{btype} eq 'rdiff-backup') {
            next;
        }
        $avcom.=" $$bh{dest}/rdiff-backup-data/session_statistics.*.data";
    }
    exec($avcom);
} elsif($COMPARE) {
  foreach my $bh (sort backup_sort (@BACKUPS)) {
    my @com;
    if ($$bh{btype} eq 'duplicity') {
      @com=($DUPLICITY_BINARY,'verify');
      $USEAGENT and push(@com,'--use-agent');
    } else {
      @com=($RDIFF_BACKUP_BINARY,'--compare','--no-eas');
    }
    push(@com,verbargs($bh),'--exclude-other-filesystems');
    foreach my $f (@{$$bh{excludes}}) {
      push(@com,'--exclude-globbing-filelist',
	   $f);
    }
    if ($$bh{btype} eq 'duplicity') {
      push(@com,$$bh{dest},$$bh{path});
    } else {
      unless($$bh{sshcompress}) {
	push(@com,'--ssh-no-compression');
      }
      push(@com,'--exclude-device-files',($$bh{host} eq $LOCALHOST ? $$bh{path} : $$bh{host}.'::'.$$bh{path}),$$bh{dest});
    }
	
    info(join(" ",@com));
    unless($TEST) {
      lock_pid_file();
      set_env($bh);
      system(@com);
      my $mainret=$?;
      unless($mainret == 0) {
	error("$$bh{btype} exited with an error");
      }
      unlock_pid_file();
    }
  }
} elsif($LIST) {
  foreach my $bh (sort backup_sort (@BACKUPS)) {
    my @com;
    unless($$bh{btype} eq 'duplicity') {
      next;
    }
    @com=($DUPLICITY_BINARY,'list-current-files');
    $USEAGENT and push(@com,'--use-agent');
    push(@com,verbargs($bh));
    push(@com,$$bh{dest});
    info(join(" ",@com));
    unless($TEST) {
      lock_pid_file();
      set_env($bh);
      system(@com);
      unless($? == 0) {
        error('unable to execute '.$com[0].'!');
      }
      unlock_pid_file();
    }
  }
} else {			# actually do a backup, please
  BACKUP:
    foreach my $bh (sort backup_sort (@BACKUPS)) {
        my @com;
        if($$bh{disabled}) {
            # skip disabled backups
            next;
        }

        if($$bh{btype} eq 'duplicity' and not -d $$bh{path}) {
            warning("backup path $$bh{path} does not exist for $$bh{tag}: skipping this backup");
            next BACKUP;
        }

        if(defined $CONFIG{$$bh{backupdestination}}{busted} and $CONFIG{$$bh{backupdestination}}{busted}) {
            # I guess this is a way to mark a backupdestination as unavailable
            next BACKUP;
        }

        if($$bh{btype} eq 'duplicity') {
            @com=($DUPLICITY_BINARY);
            $FULL and push(@com,'full');
            $USEAGENT and push(@com,'--use-agent');
	    $ALLOWSOURCEMISMATCH and push(@com,'--allow-source-mismatch');
            if(defined $$bh{signkey}) {
                push(@com,'--sign-key',$$bh{signkey});
            }
            if(defined $$bh{encryptkey}) {
                push(@com,'--encrypt-key',$$bh{encryptkey});
            }
            unless($STATS) {
                push(@com,'--no-print-statistics');
            }
            push(@com,'--exclude-other-filesystems');
        } elsif($$bh{btype} eq 'rdiff-backup') { # must be rdiff-backup
          @com=($RDIFF_BACKUP_BINARY,
                '--exclude-device-files',
                '--exclude-other-filesystems',
                '--no-eas',
               );
            unless($$bh{sshcompress}) {
                push(@com,'--ssh-no-compression');
            }
            if($STATS) {
                push(@com,'--print-statistics');
            }
        } elsif($$bh{btype} eq 'rsync') {
          @com=($RSYNC_BINARY,
                '-ax',
                '--delete',
                '--delete-excluded',
               );
          if(defined $$bh{trickle} and $$bh{trickle} =~ /^\d+$/) {
            push(@com,"--bwlimit=$$bh{trickle}");
          }
          if($$bh{sshcompress}) {
            push(@com,'-z');
          }
          if($STATS) {
            push(@com,'--stats');
          }
        }
        if(defined $TEMPDIR) {
          if(-d $TEMPDIR) {
            if($$bh{btype} eq 'rsync') {
              push(@com,"--temp-dir=$TEMPDIR");
            } else {
              push(@com,'--tempdir',$TEMPDIR);
            }
          } else {
            warn("specified temporary directory does not exist, not using it");
          }
        }
        push(@com,verbargs($bh));

        foreach my $f (@{$$bh{excludes}}) {
          if($$bh{btype} eq 'rsync') {
            push(@com,"--exclude-from=$f");
          } else { # rdiff-backup and duplicity
            push(@com,'--exclude-globbing-filelist',
                 $f);
          }
        }
        # this is fugly:
        push(@com,($$bh{host} eq $LOCALHOST ? $$bh{path} : $$bh{host}.($$bh{btype} eq 'rsync' ? ':' : '::').$$bh{path}),$$bh{dest});

        if($$bh{btype} eq 'rdiff-backup') {
	  if($$bh{dest} =~ /\:\:/) {
	    info("we are assuming the destination $$bh{dest} is remote and will not attempt to manage it's disk space");
	  } else {
            while(1) {
                my $ans=check_space($$bh{backupdestination});
                if($ans == -1) {
                    error("unable to determine if this backupdestination ($$bh{backupdestination}) has enough free space");
                    error("no backups to this backupdestination will be attempted and this message will be repeated only once");
                    $CONFIG{$$bh{backupdestination}}{busted}=1;
                    next BACKUP;
                } elsif($ans == 0) {
                    unless(remove_oldest($$bh{backupdestination})) {
                        # we failed to remove an increment from the backupdestination
                        # we cannot do backups on this bd for this run!
                        warning("unable to remove an increment on backupdestination ($$bh{backupdestination}:$CONFIG{backupdestination}{$$bh{backupdestination}}{path})");
                        warning("no further attempts will be made to do backups to this destination");
                        $CONFIG{$$bh{backupdestination}}{busted}=1;
                        next BACKUP;
                    }
                    # we can just fall out now and let check_space() run again to see if it helped
                } elsif($ans == 1) {
                    # we have enough space to proceed
                    last;
                }
	      }
	  }
        }
        # if Trickle is set for a destination, use the trickle binary to slow upload rates to the value given
        if(defined $$bh{trickle} and $$bh{trickle} =~ /^\d+$/ and $$bh{btype} ne 'rsync') {
          unshift(@com,'/usr/bin/trickle','-s','-u',$$bh{trickle});
        }
        info(join(" ",@com));

        unless($TEST) {
            lock_pid_file();

            if (defined $$bh{prerun}) {
                info($$bh{prerun});
                set_env($bh);
                system($$bh{prerun});
                unless($? == 0) {
                    # if we failed to run the pre-run, issue the final summary based on that
                    error("unable to execute prerun command: skipping backup!");
                    log_exit_status($bh,$?);
                    next;
                }
            }
            set_env($bh);
            system(@com);
            my $mainret=$?;
            unless($mainret == 0) {
                error("unable to execute $$bh{btype}!");
            }
            # if there is no postrun, return the log_exit_status using $mainret
            # if there is a postrun, return that value instead regardless of failure
            if(defined $$bh{postrun}) {
                info($$bh{postrun});
                system($$bh{postrun});
                unless($? == 0) {
                    error("unable to execute postrun command");
                }
                # issue final summary based on the return value of the postrun command
                log_exit_status($bh,$?);
            }
            else {
              # issue final summary based on the main backup process
              log_exit_status($bh,$mainret);
            }
	    unlock_pid_file();
        }
    }
}

info('exiting');

sub backup_sort {
  my @sortorder=qw( tag host backupdestination );

  unless(defined $$a{priority}) {
    $$a{priority}=(defined $$a{priority} ? $$a{priority} : 0);
  }
  unless(defined $$b{priority}) {
    $$b{priority}=(defined $$b{priority} ? $$b{priority} : 0);
  }
  if($$a{priority} != $$b{priority}) {
    return $$a{priority} <=> $$b{priority};
  }
  foreach my $parm (@sortorder) {
    if($$a{$parm} ne $$b{$parm}) {
      return $$a{$parm} cmp $$b{$parm};
    }
  }
  # somehow, all the paramaters are equal, so just return 0
  return 0;
}

sub lock_pid_file {
    unless(open(LOCK,'+<'.$LOCK_FILE) or open(LOCK,'>'.$LOCK_FILE)) {
	error("unable to open pid file: $LOCK_FILE for writing");
	die("unable to open pid file: $LOCK_FILE for writing");
    }
    unless(flock(LOCK,LOCK_EX|LOCK_NB)) {
	error("unable to flock the pid file: $LOCK_FILE");
	die("unable to flock the pid file: $LOCK_FILE");
    }
    truncate(LOCK,0); # this shouldn't fail if we have the file opened and locked!
    print LOCK $$."\n"; # who really cares if this fails?
}

sub unlock_pid_file {
    unlink $LOCK_FILE;
    flock(LOCK,LOCK_UN);
    close LOCK;
}

sub tidy {
    my $bh=$_[0];
    my $tag=$$bh{tag};
    my @com;
    if($$bh{btype} eq 'rdiff-backup') {
      @com=($RDIFF_BACKUP_BINARY,
            verbargs($bh),
            '--force',
            '--remove-older-than',
           );
      if(defined $$bh{maxinc} and not defined $$bh{increments}) {
        list_increments($bh);
      }
      if(defined $$bh{maxinc}) {
        if($$bh{maxinc} =~ /^\d+$/ and
           @{$$bh{increments}} > $$bh{maxinc} ) {
          # too many!
          debug("$tag\t Incs: ".
                scalar @{$$bh{increments}}.
                "\t Max: ".$$bh{maxinc});
          my $lastinc=(sort {$a <=> $b} (@{$$bh{increments}}))[$$bh{maxinc}-1];
          debug("last time to keep for $tag: ".localtime($lastinc));

          my @icom=(@com,$lastinc);

          push(@icom,$$bh{dest});
          info(join(" ",@icom));
          unless($TEST) {
            system(@icom);
            unless($? == 0) {
              error("unable to execute rdiff-backup!");
            }
          }
        }
      }
      if(defined $$bh{maxage} and
         $$bh{maxage} =~ /^\d/) {

        my @icom=(@com,$$bh{maxage});
        push(@icom,$$bh{dest});

        info(join(" ",@icom));
        unless($TEST) {
          system(@icom);
          unless($? == 0) {
            error("unable to execute rdiff-backup!");
          }
        }
      }
    } elsif($$bh{btype} eq 'duplicity') {
      unless(defined $$bh{maxage}) {
        debug("max age is not defined for $$bh{tag}, so we cannot tidy it");
        return;
      }
      my @com=($DUPLICITY_BINARY,
               'remove-older-than',
               $$bh{maxage},
               '--force');
      $USEAGENT and push(@com,'--use-agent');
      push(@com,verbargs($bh),
           $$bh{dest});

      info(join(" ",@com));
      unless($TEST) {
        set_env($bh);
        system(@com);
        unless($? == 0) {
          error("unable to execute duplicity!");
        }
      }
    }
  }

sub debug {
  $DISPATCHER->debug(@_);
}
sub info {
  $DISPATCHER->info(@_);
}
sub notice {
  $DISPATCHER->notice(@_);
}
sub warning {
  $DISPATCHER->warning(@_);
}
sub error {
  $DISPATCHER->error(@_);
}
sub critical {
  $DISPATCHER->critical(@_);
}
sub alert {
  $DISPATCHER->alert(@_);
}
sub emergency {
  $DISPATCHER->emergency(@_);
}

sub set_env {
    my $bh=$_[0];
    # grab more stuff from the config and put them into ENV for use by duplicity
    if(defined $$bh{gpgpassphrase}) {
	$ENV{PASSPHRASE}=$$bh{gpgpassphrase};
    }
    if($$bh{dest} =~ /^s3/) {
	if(defined $$bh{awsaccesskeyid}) {
	    $ENV{AWS_ACCESS_KEY_ID}=$$bh{awsaccesskeyid};
	}
	if(defined $$bh{awssecretaccesskey}) {
	    $ENV{AWS_SECRET_ACCESS_KEY}=$$bh{awssecretaccesskey};
	}
    }
}

sub create_dispatcher {
  $DISPATCHER=Log::Dispatch->new( callbacks => $callback_clean );

  $DISPATCHER->add(Log::Dispatch::Syslog->new(name      => 'syslog',
					      min_level => $LOG_LEVEL,
					      ident     => 'rdbduprunner'.'['.$$.']',
					      facility  => $FACILITY,
					      socket    => 'unix',
					     )
		  );

  $DISPATCHER->add(Log::Dispatch::Screen->new(name      => 'screen',
					      min_level => $LOG_LEVEL,
					      stderr    => 0,
					     )
		  );
  $DISPATCHER->add(
                   Log::Dispatch::File->new(
                                            name      => 'logfile',
                                            min_level => $LOG_LEVEL,
                                            filename  => $LOG_FILE,
                                            mode      => '>>',
                                           )
                  );
}

sub verbargs {
  my $bh=$_[0];
  my @a;
  if($$bh{btype} ne 'rsync') {
    if(defined $VERBOSITY) {
      push(@a,'--verbosity',$VERBOSITY);
    }
    if(defined $TVERBOSITY and $$bh{btype} eq 'rdiff-backup') {
      push(@a,'--terminal-verbosity',$TVERBOSITY);
    }
  } elsif(defined $TVERBOSITY and $TVERBOSITY > 3) {
    @a='-v';
  }
  @a;
}

sub build_increment_list {
  foreach my $bp (@BACKUPS) {
    my $tag=$$bp{tag};
    unless($$bp{btype} eq 'rdiff-backup') {
      next;
    }
	unless(defined $$bp{increments}) {
	    list_increments($bp);
	}
	foreach my $inctime (@{$$bp{increments}}) {
	    # find various tidbits of info about this increment
	    # /home/spin/rdiff-backup/spidermonk-home-spin-wine-wow/rdiff-backup-data/session_statistics.2008-02-22T03:05:48-06:00.data
	    my @d=localtime($inctime);
	    my $rbdate=strftime("%FT%T",@d);
	    my $glob="$$bp{dest}/rdiff-backup-data/session_statistics.$rbdate*.data";
	    my $ssdfile=(glob($glob))[0];
	    my $data={}; # store info from the session stats file... which we never ever ever use!
	    
	    if(defined $ssdfile) {
		if(open(SSD,$ssdfile)) {
		    foreach my $ln (<SSD>) {
			$ln =~ /^(\w+)\s+(\d+\.?\d*)/ and $$data{$1}=$2;
		    }
		    close(SSD);
		} else {
		    error("unable to open increment file: $glob $ssdfile");
		}
	    } else {
		notice("unable to find the session statistics file for this increment: $tag $rbdate using glob: $glob");
	    }

	    push(@INCREMENTS,{ inctime => $inctime,
                           incdt => [@d],
                           ssdfile => $ssdfile,
                           ssddata => $data,
                           tag     => $tag,
                           bh      => $bp,
                           backupdestination => $$bp{backupdestination},
                         }
		);
	}
    }
    #print Dumper \@INCREMENTS;
}

sub list_increments {
    my $bp=$_[0];

    my $c="$RDIFF_BACKUP_BINARY -l --parsable-output ".$$bp{dest};
    debug($c);
    my @res=`$c`;
    #@res == 1 and next; # if there is only one increment, don't consider it for removal
    foreach my $ln (@res) {
      chomp $ln;
      $ln =~ /^(\d+)\sdirectory$/ or next;
      push(@{$$bp{increments}},$1);
    }
}

sub remove_oldest {
    my $backupdest=$_[0];

    unless(@INCREMENTS > 0) {
	build_increment_list();
    }
    foreach my $ih (sort { $$a{inctime} <=> $$b{inctime} } (@INCREMENTS)) {
	debug("remove_oldest: $$ih{inctime}");
	if(defined $$ih{removed} and $$ih{removed}) {
	    debug("cannot remove previously removed increment for $$ih{tag}");
	    next;
	}
	if(scalar @{$$ih{bh}{increments}} == 1) {
	    # cannot remove the only increment!
	    debug("cannot remove only increment for $$ih{tag}");
	    next;
	}
	unless($backupdest eq 'any' or
	       $backupdest eq $$ih{bh}{backupdestination}) {
	    debug("skipping because it isn't in the backupdestination we are looking for: $backupdest $$ih{bh}{backupdestination}");
	    next;
	}
	my $t=$$ih{inctime};
	my @com=($RDIFF_BACKUP_BINARY,
             verbargs($$ih{bh}),
		 '--remove-older-than',($t+1), # do I really need to add 1?
		 $$ih{bh}{dest});
	info(join(" ",@com));
	unless($TEST) {
	    system(@com);
	    unless($? == 0) {
		error("rdiff-backup did not exit cleanly!");
		return 0;
	    }
	}
	$$ih{removed}=1;
#	print Dumper $BACKUPS{$$ih{tag}}{increments};
	shift(@{$$ih{bh}{increments}});
#	print Dumper $BACKUPS{$$ih{tag}}{increments};
	return 1;
    }
}

sub check_space {
    my $bh=$CONFIG{backupdestination}{$_[0]};
    update_bd_space($bh) or return -1;    
    if(defined $$bh{minfree} and $$bh{avail} < $$bh{minfree}) {
	return 0;
    } elsif(defined $$bh{percentused} and $$bh{percent} > $$bh{percentused}) {
	return 0;
    }
    return 1;
}

sub update_bd_space {
    my $bh=$_[0];
    my $com='POSIXLY_CORRECT=1 BLOCKSIZE=512 df -P '.$$bh{path};
    my @a=`$com`;
    unless($? == 0) {
	error("unable to run \"$com\": no further backups will be attempted to this directory");
	$$bh{busted}=1;
	return 0;
    }
    unless($a[1] =~ /(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\%/) {
	error("unable to parse output from \"$com\": no further backups will be attempted to this directory");
	$$bh{busted}=1;
	return 0;
    }
    $$bh{size}=$1;
    $$bh{used}=$2;
    $$bh{avail}=$3;
    $$bh{percent}=$4;
    return 1;
}

sub log_exit_status {
  my($bh,$exit)=@_;
  notice(stringy({'msg' => 'exit status', 'exit' => $exit, timestamp => time(), datetime => localtime().""},$bh));
}

sub stringy {
  # each element passed to stringy should be a HASH REF
  my @a; # strings
  foreach my $h (@_) {
    next unless ref $h eq 'HASH';
    foreach my $key (keys(%$h)) {
      next if ref ${$h}{$key}; # must not be a reference
      my $val=${$h}{$key};
      $val =~ s/\n/NL/g; # remove newlines
      $val =~ s/"/\\"/g; # replace " with \"
      push(@a,"$key=\"$val\"");
    }
  }
  return join(" ",@a);
}
