#! /usr/bin/perl
# Copyright Aran Cox <arancox@gmail.com>

use strict;
use warnings;

#from a standard perl distribution, on UNIX at least
use Getopt::Long;
use Fcntl qw(:DEFAULT :flock); # import LOCK_* constants
use Env qw( HOME USER );
use Data::Dumper;
use POSIX qw( strftime );
use Pod::Usage;

# added from CPAN or system packages
use Config::General;
use Log::Dispatch;
use Log::Dispatch::Syslog;
use Log::Dispatch::Screen;
use Log::Dispatch::File;

# print usage and exit
my $HELP=0;

# can be overridden from the command line, but not the config
our $CONFIG_FILE="$HOME/.rdbduprunner.rc";

# these are command line options, and in some cases config file options
# the following changes the major mode of operation for rdbduprunner:
our $AVERAGE=0;
our $CLEANUP=0;
our $COMPARE=0;
our $DUMP=0;
our $LISTOLDEST=0;
our $REMOVE=0;
our $STATUS=0;
our $TIDY=0;
our $LIST=0;
# the following affect what options are passed to rdiff-backup and/or duplicity
our $FORCE=0;
our $FULL=0;
our $MAXAGE;
our $MAXINC;
our $STATS=1;
our $VERBOSITY;
our $TVERBOSITY;
our $USEAGENT;
our $ALLOWSOURCEMISMATCH=0;
our $TEMPDIR;
# rsync specific
my $VERBOSE=0;
my $PROGRESS=0;
# the next three options limit which backups get acted upon
our $DEST;
our $HOST;
our $PATH;
# configuring rdbduprunner:
our $DUPLICITY_BINARY;
our $RDIFF_BACKUP_BINARY;
our $RSYNC_BINARY;
our $EXCLUDE_PATH;
our $FACILITY='user';
our $LOG_LEVEL='info';
our $LOCALHOST;
our $LOCK_FILE;
our $LOG_FILE=($USER eq 'root' ? '/var/log/rdbduprunner.log' : $HOME.'/var/log/rdbduprunner.log');
my $LOG_DIR=($USER eq 'root' ? '/var/log/rdbduprunner' : $HOME.'/var/log/rdbduprunner');
our $TEST=1;

# global variables
our %CONFIG;
our @BACKUPS;
our $DISPATCHER;
our @INCREMENTS;

GetOptions(
           # show usage
           'h|help'                 => \$HELP,
           # can be overridden from the command line, but not the config
           'config=s'               => \$CONFIG_FILE, # config file

           # the following changes the major mode of operation for rdbduprunner:
           'calculate-average'      => \$AVERAGE,
           'cleanup'                => \$CLEANUP,
           'check'                  => \$CLEANUP,
           'compare'                => \$COMPARE,
           'verify'                 => \$COMPARE,
           'dump'                   => \$DUMP,
           'list-oldest'            => \$LISTOLDEST,
           'remove-oldest'          => \$REMOVE,
           'status'                 => \$STATUS,
           'tidy'                   => \$TIDY,
           'list'                   => \$LIST,

           # the following affect what options are passed to rdiff-backup and/or duplicity
           'force!'                 => \$FORCE,
           'full'                   => \$FULL,
           'maxage=s'               => \$MAXAGE,
           'maxinc=s'               => \$MAXINC,
           'stats!'                 => \$STATS,
           'verbosity=i'            => \$VERBOSITY,
           't|terminal-verbosity=i' => \$TVERBOSITY,
           'u|use-agent!'           => \$USEAGENT,
           'allow-source-mismatch!' => \$ALLOWSOURCEMISMATCH,
           'tempdir=s'              => \$TEMPDIR,

           # rsync specific options
           'v|verbose'              => \$VERBOSE,
           'progress!'              => \$PROGRESS,
           'logdir=s'               => \$LOG_DIR,
           # the next three options limit which backups get acted upon
           'dest=s'                 => \$DEST,
           'host=s'                 => \$HOST,
           'path=s'                 => \$PATH,

           # configuring rdbduprunner:
           'duplicity-binary=s'     => \$DUPLICITY_BINARY,
           'rdiff-backup-binary=s'  => \$RDIFF_BACKUP_BINARY,
           'rsync-binary=s'         => \$RSYNC_BINARY,
           'exclude-path=s'         => \$EXCLUDE_PATH,
           'facility=s'             => \$FACILITY,
           'level=s'                => \$LOG_LEVEL,
           'localhost=s'            => \$LOCALHOST,
           'lockfile=s'             => \$LOCK_FILE,
           'logfile=s'              => \$LOG_FILE,
           'test!'                  => \$TEST,
          );

# print the SYNOPSIS section and exit
pod2usage(-1) if $HELP;

if(not defined $LOCALHOST) {
  if(defined $CONFIG{localhost}) {
    $LOCALHOST=$CONFIG{localhost};
  } else {
    $LOCALHOST=`hostname`;
    chomp $LOCALHOST;
    my @a=split(/\./,$LOCALHOST);
    @a > 1 and $LOCALHOST=$a[0];
  }
}

my $callback_clean = sub { my %t=@_;
                           chomp $t{message};
                           return $t{message}."\n"; # add a newline
                         };

create_dispatcher();
info('starting');

%CONFIG=new Config::General(-ConfigFile => $CONFIG_FILE,
			    -IncludeGlob => 1,
			    -AutoTrue => 1,
			    -LowerCaseNames => 1)->getall() or die "unable to parse $CONFIG_FILE";

if(not defined $DUPLICITY_BINARY) {
    if(defined $CONFIG{duplicitybinary}) {
	$DUPLICITY_BINARY=$CONFIG{duplicitybinary};
    } else {
	$DUPLICITY_BINARY='duplicity'; # in our path we hope
    }
}

if(not defined $RDIFF_BACKUP_BINARY) {
    if(defined $CONFIG{rdiffbackupbinary}) {
	$RDIFF_BACKUP_BINARY=$CONFIG{rdiffbackupbinary};
    } else {
	$RDIFF_BACKUP_BINARY='rdiff-backup'; # in our path we hope
    }
}

if(not defined $RSYNC_BINARY) {
  if(defined $CONFIG{rsyncbinary}) {
	$RSYNC_BINARY=$CONFIG{rsyncbinary};
  } else {
	$RSYNC_BINARY='rsync'; # in our path we hope
  }
}

unless(defined $VERBOSITY) { # from the command line
  if(defined $CONFIG{verbosity}) {
    $VERBOSITY=$CONFIG{verbosity};
  }
}

unless(defined $TVERBOSITY) { # from the command line
  if(defined $CONFIG{terminalverbosity}) {
    $TVERBOSITY=$CONFIG{terminalverbosity};
  }
}

if(defined $LOCK_FILE) {
  # leave it alone, it comes from the command line
} elsif(defined $CONFIG{lockfile}) {
  $LOCK_FILE=$CONFIG{lockfile};
} else {
  $LOCK_FILE="$HOME/rdbduprunner.pid";
}

if(defined $EXCLUDE_PATH) {
  # leave it alone, it comes from the command line
} elsif(defined $CONFIG{excludepath}) {
  $EXCLUDE_PATH=$CONFIG{excludepath};
} else {
  $EXCLUDE_PATH='/etc/rdbduprunner-excludes';
}

if(not defined $USEAGENT) {
  if(defined $CONFIG{useagent}) {
    $USEAGENT=1;
  } else {
    $USEAGENT=0;
  }
}

if(not defined $TEMPDIR) {
  if(defined $CONFIG{tempdir}) {
    $TEMPDIR=$CONFIG{tempdir};
  }
}

foreach my $bstag (keys(%{$CONFIG{backupset}})) {
    my $bs=$CONFIG{backupset}{$bstag};
    my $host=(defined $$bs{host} ? $$bs{host} : $LOCALHOST);
    my $btype;
    my $backupdest;

    if(defined $HOST and $host !~ /$HOST/) {
      next;
    }

    if(defined $$bs{backupdestination}) {
        $backupdest=$$bs{backupdestination};
    } elsif(defined $CONFIG{defaultbackupdestination}) {
        $backupdest=$CONFIG{defaultbackupdestination};
    }
    unless(defined $backupdest) {
        error("there is no BackupDestination defined for the BackupSet ($bstag): so it cannot be processed");
        next;
    }
    if(defined $CONFIG{backupdestination}{$backupdest}{type} and
           $CONFIG{backupdestination}{$backupdest}{type} =~ /^(rdiff\-backup|duplicity|rsync)$/) {
      # check to make sure that if the type isn't set, we set it to rsync
      $btype=$CONFIG{backupdestination}{$backupdest}{type};
    } else {
      $btype='rsync';
    }
    if($btype eq 'duplicity' and $host ne $LOCALHOST) {
      error("$bstag is a duplicity backup with host set to $host: duplicity backups must have a local source!");
      next;
    }

    if(defined $DEST and $backupdest !~ /$DEST/) {
        next;
    }
    my $backupdestpath=$CONFIG{backupdestination}{$backupdest}{path};

    foreach my $path (ref($$bs{path}) eq "ARRAY" ? @{$$bs{path}} : ($$bs{path})) {
        $path =~ s/.+\/$//; # remove any trailing slash, but only if there is something before it!
        my $bh={};
        if(defined $PATH and $path !~ /$PATH/) {
            next;
        }
        my $dest;
        my $tag='';
        if(defined $$bs{tag}) {
            $dest=$$bs{tag};
            $tag=$dest;
        } else {
            $dest=$path;
            $dest =~ s/\//\-/g;
            $dest =~ s/ /_/g;
            $dest eq '-' and $dest='-root';
            $tag=$host.$dest;
        }
        # I should use a perl module here, I guess, not .
        $dest=$backupdestpath.'/'.$tag;
        my @tags=split(/\-/,$tag);

        debug("Host: $host Path: $path Tag: $tag Dest: $dest Root: $backupdestpath");

        $bh={%{$bs}}; # very important to make a copy here
        $$bh{dest}=$dest;
        $$bh{path}=$path;
        $$bh{tag}=$tag;
        $$bh{host}=$host;
        $$bh{backupdestination}=$backupdest;
        $$bh{gtag}='generic-'.$tags[1];
        $$bh{btype}=$btype;
        if($$bh{btype} eq 'rsync') {
          $$bh{path}=$$bh{path}.'/';
        }
        if( -f $EXCLUDE_PATH.'/exclude-generic' ) {
            push(@{$$bh{excludes}},$EXCLUDE_PATH.'/exclude-generic');
        }

        if( -f $EXCLUDE_PATH.'/exclude-'.$$bh{gtag} ) {
            push(@{$$bh{excludes}},$EXCLUDE_PATH.'/exclude-'.$$bh{gtag});
        }

        if( -f $EXCLUDE_PATH.'/exclude-'.$tag ) {
            push(@{$$bh{excludes}},$EXCLUDE_PATH.'/exclude-'.$tag);
        }
        $$bh{exclude}=[];
        foreach my $exc (ref($$bs{exclude}) eq "ARRAY" ? @{$$bs{exclude}} : ($$bs{exclude})) {
          if(defined $exc and length $exc > 0) {
            push(@{$$bh{exclude}},$exc);
          }
        }
        if(defined $MAXAGE) {
            $$bh{maxage}=$MAXAGE;
        } elsif(not defined $$bh{maxage} and
                defined $CONFIG{maxage}) {
            $$bh{maxage}=$CONFIG{maxage};
        }
        if(defined $MAXINC) {
            $$bh{maxinc}=$MAXINC;
        } elsif(not defined $$bh{maxinc} and
                defined $CONFIG{maxinc}) {
            $$bh{maxinc}=$CONFIG{maxinc};
        }
        # if this is defined in a backupset, allow that to override the global definition, if it exists
        foreach my $var (sort(map(lc,qw( GPGPassPhrase AWSAccessKeyID AWSSecretAccessKey SignKey EncryptKey Trickle )))) {
            unless(defined $$bh{$var}) {
                if(defined $CONFIG{$var}) {
                    $$bh{$var}=$CONFIG{$var};
                }
                if(defined $CONFIG{backupdestination}{$$bh{backupdestination}}{$var}) {
                    # the above is why people hate perl, possibly
                    $$bh{$var}=$CONFIG{backupdestination}{$$bh{backupdestination}}{$var};
                }
            }
        }
        push(@BACKUPS,$bh);
    }
}

if($DUMP) {
  print Dumper \%CONFIG;
  print Dumper \@BACKUPS;
  notice("you asked me to dump and exit!");
  exit(0);
}

if($STATUS) {
  foreach my $bh (sort backup_sort (@BACKUPS)) {
    my @com;
    if($$bh{btype} eq 'duplicity') {
      @com=($DUPLICITY_BINARY,'collection-status');
      $USEAGENT and push(@com,'--use-agent');
    } elsif($$bh{btype} eq 'rdiff-backup') {
      @com=($RDIFF_BACKUP_BINARY,'-l');
    } elsif($$bh{btype} eq 'rsync') {
      @com=('du','-cshx');
    }
    unless($$bh{btype} eq 'rsync') {
      push(@com,verbargs($bh));

    }
    push(@com,$$bh{dest});
    info(join(" ",@com));
    unless($TEST) {
      lock_pid_file();
      set_env($bh);
      system(@com);
      unless($? == 0) {
        error('unable to execute '.$com[0].'!');
      }
      unlock_pid_file();
    }
  }
} elsif($LISTOLDEST) {
    build_increment_list();
    foreach my $ih (sort { $$a{inctime} <=> $$b{inctime} } (@INCREMENTS)) {
        print localtime($$ih{inctime}).' '.$$ih{bh}{dest}.' '.$$ih{tag}."\n";
    }
} elsif($REMOVE) {
    build_increment_list();
    remove_oldest('any');
} elsif($CLEANUP) {
    foreach my $bh (sort backup_sort (@BACKUPS)) {
        my @com;
        if($$bh{btype} eq 'duplicity') {
            push(@com,$DUPLICITY_BINARY,'cleanup');
            $USEAGENT and push(@com,'--use-agent');
            if($FORCE) {
                push(@com,'--force');
            }
        } elsif($$bh{btype} eq 'rdiff-backup') {
            push(@com,$RDIFF_BACKUP_BINARY,'--check-destination-dir');
        }
        else {
          warn("cleanup function only implmented for duplicity and rdiff-backup");
          next;
        }
        push(@com,verbargs($bh),
             $$bh{dest});
        info(join(" ",@com));
        unless($TEST) {
            lock_pid_file();
            set_env($bh);
            system(@com);
            unless($? == 0) {
                error("unable to execute $$bh{btype}!");
            }
            unlock_pid_file();
        }
    }
} elsif ($TIDY) {
    foreach my $bh (sort backup_sort (@BACKUPS)) {
      unless($TEST) {
	lock_pid_file();
      }
        tidy($bh);
      unless($TEST) {
	unlock_pid_file();
      }
    }
} elsif($AVERAGE) {
    my $avcom="$RDIFF_BACKUP_BINARY --calculate-average";
    foreach my $bh (sort backup_sort (@BACKUPS)) {
        unless($$bh{btype} eq 'rdiff-backup') {
          warn("average function only applies to rdiff-backup type backupes");
            next;
        }
        $avcom.=" $$bh{dest}/rdiff-backup-data/session_statistics.*.data";
    }
    exec($avcom);
} elsif($COMPARE) {
  foreach my $bh (sort backup_sort (@BACKUPS)) {
    my @com;
    if ($$bh{btype} eq 'duplicity') {
      @com=($DUPLICITY_BINARY,'verify');
      $USEAGENT and push(@com,'--use-agent');
    }
    elsif($$bh{btype} eq 'rdiff-backup') {
      @com=($RDIFF_BACKUP_BINARY,'--compare','--no-eas');
    }
    else {
      warn("verify function not implemented for rsync backups");
      next;
    }
    push(@com,verbargs($bh),'--exclude-other-filesystems');
    foreach my $f (@{$$bh{excludes}}) {
      push(@com,'--exclude-globbing-filelist',
	   $f);
    }
    if ($$bh{btype} eq 'duplicity') {
      push(@com,$$bh{dest},$$bh{path});
    } else {
      unless($$bh{sshcompress}) {
	push(@com,'--ssh-no-compression');
      }
      push(@com,'--exclude-device-files',($$bh{host} eq $LOCALHOST ? $$bh{path} : $$bh{host}.'::'.$$bh{path}),$$bh{dest});
    }
	
    info(join(" ",@com));
    unless($TEST) {
      lock_pid_file();
      set_env($bh);
      system(@com);
      my $mainret=$?;
      unless($mainret == 0) {
	error("$$bh{btype} exited with an error");
      }
      unlock_pid_file();
    }
  }
} elsif($LIST) {
  foreach my $bh (sort backup_sort (@BACKUPS)) {
    my @com;
    unless($$bh{btype} eq 'duplicity') {
      warn("list function only applies to duplicity type backups");
      next;
    }
    @com=($DUPLICITY_BINARY,'list-current-files');
    $USEAGENT and push(@com,'--use-agent');
    push(@com,verbargs($bh));
    push(@com,$$bh{dest});
    info(join(" ",@com));
    unless($TEST) {
      lock_pid_file();
      set_env($bh);
      system(@com);
      unless($? == 0) {
        error('unable to execute '.$com[0].'!');
      }
      unlock_pid_file();
    }
  }
} else {			# actually do a backup, please
  BACKUP:
    foreach my $bh (sort backup_sort (@BACKUPS)) {
        my @com;
        if($$bh{disabled}) {
            # skip disabled backups
            next;
        }

        if($$bh{btype} eq 'duplicity' and not -d $$bh{path}) {
            warning("backup path $$bh{path} does not exist for $$bh{tag}: skipping this backup");
            next BACKUP;
        }

        if(defined $CONFIG{$$bh{backupdestination}}{busted} and $CONFIG{$$bh{backupdestination}}{busted}) {
            # I guess this is a way to mark a backupdestination as unavailable
            next BACKUP;
        }

        if($$bh{btype} eq 'duplicity') {
            @com=($DUPLICITY_BINARY);
            $FULL and push(@com,'full');
            $USEAGENT and push(@com,'--use-agent');
	    $ALLOWSOURCEMISMATCH and push(@com,'--allow-source-mismatch');
            if(defined $$bh{signkey}) {
                push(@com,'--sign-key',$$bh{signkey});
            }
            if(defined $$bh{encryptkey}) {
                push(@com,'--encrypt-key',$$bh{encryptkey});
            }
            unless($STATS) {
                push(@com,'--no-print-statistics');
            }
            push(@com,'--exclude-other-filesystems');
        } elsif($$bh{btype} eq 'rdiff-backup') { # must be rdiff-backup
          @com=($RDIFF_BACKUP_BINARY,
                '--exclude-device-files',
                '--exclude-other-filesystems',
                '--no-eas',
               );
            unless($$bh{sshcompress}) {
                push(@com,'--ssh-no-compression');
            }
            if($STATS) {
                push(@com,'--print-statistics');
            }
        } elsif($$bh{btype} eq 'rsync') {
          @com=($RSYNC_BINARY,
                '-ax',
                '--delete',
                '--delete-excluded',
               );
          if(defined $$bh{trickle} and $$bh{trickle} =~ /^\d+$/) {
            push(@com,"--bwlimit=$$bh{trickle}");
          }
          if($$bh{sshcompress}) {
            push(@com,'-z');
          }
          if($STATS) {
            push(@com,'--stats');
          }
          # use logging
          push(@com,'--log-file='.$LOG_DIR.'/'.$$bh{tag}.'.log')
        }
        if(defined $TEMPDIR) {
          if(-d $TEMPDIR) {
            if($$bh{btype} eq 'rsync') {
              push(@com,"--temp-dir=$TEMPDIR");
            } else {
              push(@com,'--tempdir',$TEMPDIR);
            }
          } else {
            warn("specified temporary directory does not exist, not using it");
          }
        }
        push(@com,verbargs($bh));

        foreach my $f (@{$$bh{excludes}}) {
          if($$bh{btype} eq 'rsync') {
            push(@com,"--exclude-from=$f");
          } else { # rdiff-backup and duplicity
            push(@com,'--exclude-globbing-filelist',
                 $f);
          }
        }
        foreach my $x (@{$$bh{exclude}}) {
          push(@com,'--exclude',$x);
        }
        # this is fugly:
        push(@com,($$bh{host} eq $LOCALHOST ? $$bh{path} : $$bh{host}.($$bh{btype} eq 'rsync' ? ':' : '::').$$bh{path}),$$bh{dest});

        if($$bh{btype} eq 'rdiff-backup') {
	  if($$bh{dest} =~ /\:\:/) {
	    info("we are assuming the destination $$bh{dest} is remote and will not attempt to manage it's disk space");
	  } else {
            while(1) {
                my $ans=check_space($$bh{backupdestination});
                if($ans == -1) {
                    error("unable to determine if this backupdestination ($$bh{backupdestination}) has enough free space");
                    error("no backups to this backupdestination will be attempted and this message will be repeated only once");
                    $CONFIG{$$bh{backupdestination}}{busted}=1;
                    next BACKUP;
                } elsif($ans == 0) {
                    unless(remove_oldest($$bh{backupdestination})) {
                        # we failed to remove an increment from the backupdestination
                        # we cannot do backups on this bd for this run!
                        warning("unable to remove an increment on backupdestination ($$bh{backupdestination}:$CONFIG{backupdestination}{$$bh{backupdestination}}{path})");
                        warning("no further attempts will be made to do backups to this destination");
                        $CONFIG{$$bh{backupdestination}}{busted}=1;
                        next BACKUP;
                    }
                    # we can just fall out now and let check_space() run again to see if it helped
                } elsif($ans == 1) {
                    # we have enough space to proceed
                    last;
                }
	      }
	  }
        }
        # if Trickle is set for a destination, use the trickle binary to slow upload rates to the value given
        if(defined $$bh{trickle} and $$bh{trickle} =~ /^\d+$/ and $$bh{btype} ne 'rsync') {
          unshift(@com,'/usr/bin/trickle','-s','-u',$$bh{trickle});
        }
        info(join(" ",@com));

        unless($TEST) {
            lock_pid_file();

            if (defined $$bh{prerun}) {
                info($$bh{prerun});
                set_env($bh);
                system($$bh{prerun});
                unless($? == 0) {
                    # if we failed to run the pre-run, issue the final summary based on that
                    error("unable to execute prerun command: skipping backup!");
                    log_exit_status($bh,$?);
                    next;
                }
            }
            set_env($bh);
            system(@com);
            my $mainret=$?;
            unless($mainret == 0) {
                error("unable to execute $$bh{btype}!");
            }
            # if there is no postrun, return the log_exit_status using $mainret
            # if there is a postrun, return that value instead regardless of failure
            if(defined $$bh{postrun}) {
                info($$bh{postrun});
                system($$bh{postrun});
                unless($? == 0) {
                    error("unable to execute postrun command");
                }
                # issue final summary based on the return value of the postrun command
                log_exit_status($bh,$?);
            }
            else {
              # issue final summary based on the main backup process
              log_exit_status($bh,$mainret);
            }
	    unlock_pid_file();
        }
    }
}

info('exiting');

sub backup_sort {
  my @sortorder=qw( tag host backupdestination );

  unless(defined $$a{priority}) {
    $$a{priority}=(defined $$a{priority} ? $$a{priority} : 0);
  }
  unless(defined $$b{priority}) {
    $$b{priority}=(defined $$b{priority} ? $$b{priority} : 0);
  }
  if($$a{priority} != $$b{priority}) {
    return $$a{priority} <=> $$b{priority};
  }
  foreach my $parm (@sortorder) {
    if($$a{$parm} ne $$b{$parm}) {
      return $$a{$parm} cmp $$b{$parm};
    }
  }
  # somehow, all the paramaters are equal, so just return 0
  return 0;
}

sub lock_pid_file {
    unless(open(LOCK,'+<'.$LOCK_FILE) or open(LOCK,'>'.$LOCK_FILE)) {
	error("unable to open pid file: $LOCK_FILE for writing");
	die("unable to open pid file: $LOCK_FILE for writing");
    }
    unless(flock(LOCK,LOCK_EX|LOCK_NB)) {
	error("unable to flock the pid file: $LOCK_FILE");
	die("unable to flock the pid file: $LOCK_FILE");
    }
    truncate(LOCK,0); # this shouldn't fail if we have the file opened and locked!
    print LOCK $$."\n"; # who really cares if this fails?
}

sub unlock_pid_file {
    unlink $LOCK_FILE;
    flock(LOCK,LOCK_UN);
    close LOCK;
}

sub tidy {
    my $bh=$_[0];
    my $tag=$$bh{tag};
    my @com;
    if($$bh{btype} eq 'rdiff-backup') {
      @com=($RDIFF_BACKUP_BINARY,
            verbargs($bh),
            '--force',
            '--remove-older-than',
           );
      if(defined $$bh{maxinc} and not defined $$bh{increments}) {
        list_increments($bh);
      }
      if(defined $$bh{maxinc}) {
        if($$bh{maxinc} =~ /^\d+$/ and
           @{$$bh{increments}} > $$bh{maxinc} ) {
          # too many!
          debug("$tag\t Incs: ".
                scalar @{$$bh{increments}}.
                "\t Max: ".$$bh{maxinc});
          my $lastinc=(sort {$a <=> $b} (@{$$bh{increments}}))[$$bh{maxinc}-1];
          debug("last time to keep for $tag: ".localtime($lastinc));

          my @icom=(@com,$lastinc);

          push(@icom,$$bh{dest});
          info(join(" ",@icom));
          unless($TEST) {
            system(@icom);
            unless($? == 0) {
              error("unable to execute rdiff-backup!");
            }
          }
        }
      }
      if(defined $$bh{maxage} and
         $$bh{maxage} =~ /^\d/) {

        my @icom=(@com,$$bh{maxage});
        push(@icom,$$bh{dest});

        info(join(" ",@icom));
        unless($TEST) {
          system(@icom);
          unless($? == 0) {
            error("unable to execute rdiff-backup!");
          }
        }
      }
    } elsif($$bh{btype} eq 'duplicity') {
      unless(defined $$bh{maxage}) {
        debug("max age is not defined for $$bh{tag}, so we cannot tidy it");
        return;
      }
      my @com=($DUPLICITY_BINARY,
               'remove-older-than',
               $$bh{maxage},
               '--force');
      $USEAGENT and push(@com,'--use-agent');
      push(@com,verbargs($bh),
           $$bh{dest});

      info(join(" ",@com));
      unless($TEST) {
        set_env($bh);
        system(@com);
        unless($? == 0) {
          error("unable to execute duplicity!");
        }
      }
    }
    else {
      warn("tidy only applies to duplicity and rdiff-backup");
    }
  }

sub debug {
  $DISPATCHER->debug(@_);
}
sub info {
  $DISPATCHER->info(@_);
}
sub notice {
  $DISPATCHER->notice(@_);
}
sub warning {
  $DISPATCHER->warning(@_);
}
sub error {
  $DISPATCHER->error(@_);
}
sub critical {
  $DISPATCHER->critical(@_);
}
sub alert {
  $DISPATCHER->alert(@_);
}
sub emergency {
  $DISPATCHER->emergency(@_);
}

sub set_env {
    my $bh=$_[0];
    # grab more stuff from the config and put them into ENV for use by duplicity
    if(defined $$bh{gpgpassphrase}) {
	$ENV{PASSPHRASE}=$$bh{gpgpassphrase};
    }
    if($$bh{dest} =~ /^s3/) {
	if(defined $$bh{awsaccesskeyid}) {
	    $ENV{AWS_ACCESS_KEY_ID}=$$bh{awsaccesskeyid};
	}
	if(defined $$bh{awssecretaccesskey}) {
	    $ENV{AWS_SECRET_ACCESS_KEY}=$$bh{awssecretaccesskey};
	}
    }
}

sub create_dispatcher {
  $DISPATCHER=Log::Dispatch->new( callbacks => $callback_clean );

  $DISPATCHER->add(Log::Dispatch::Syslog->new(name      => 'syslog',
					      min_level => $LOG_LEVEL,
					      ident     => 'rdbduprunner'.'['.$$.']',
					      facility  => $FACILITY,
					      socket    => 'unix',
					     )
		  );

  $DISPATCHER->add(Log::Dispatch::Screen->new(name      => 'screen',
					      min_level => $LOG_LEVEL,
					      stderr    => 0,
					     )
		  );
  $DISPATCHER->add(
                   Log::Dispatch::File->new(
                                            name      => 'logfile',
                                            min_level => $LOG_LEVEL,
                                            filename  => $LOG_FILE,
                                            mode      => '>>',
                                           )
                  );
}

sub verbargs {
  my $bh=$_[0];
  my @a;
  if($$bh{btype} ne 'rsync') {
    if(defined $VERBOSITY) {
      push(@a,'--verbosity',$VERBOSITY);
    }
    if(defined $TVERBOSITY and $$bh{btype} eq 'rdiff-backup') {
      push(@a,'--terminal-verbosity',$TVERBOSITY);
    }
  }
  else {
    if($PROGRESS) {
      push(@a,'--progress');
    }
    if($VERBOSE) {
      push(@a,'-v');
    }
  }
  @a;
}

sub build_increment_list {
  foreach my $bp (@BACKUPS) {
    my $tag=$$bp{tag};
    unless($$bp{btype} eq 'rdiff-backup') {
      next;
    }
	unless(defined $$bp{increments}) {
	    list_increments($bp);
	}
	foreach my $inctime (@{$$bp{increments}}) {
	    # find various tidbits of info about this increment
	    # /home/spin/rdiff-backup/spidermonk-home-spin-wine-wow/rdiff-backup-data/session_statistics.2008-02-22T03:05:48-06:00.data
	    my @d=localtime($inctime);
	    my $rbdate=strftime("%FT%T",@d);
	    my $glob="$$bp{dest}/rdiff-backup-data/session_statistics.$rbdate*.data";
	    my $ssdfile=(glob($glob))[0];
	    my $data={}; # store info from the session stats file... which we never ever ever use!
	    
	    if(defined $ssdfile) {
		if(open(SSD,$ssdfile)) {
		    foreach my $ln (<SSD>) {
			$ln =~ /^(\w+)\s+(\d+\.?\d*)/ and $$data{$1}=$2;
		    }
		    close(SSD);
		} else {
		    error("unable to open increment file: $glob $ssdfile");
		}
	    } else {
		notice("unable to find the session statistics file for this increment: $tag $rbdate using glob: $glob");
	    }

	    push(@INCREMENTS,{ inctime => $inctime,
                           incdt => [@d],
                           ssdfile => $ssdfile,
                           ssddata => $data,
                           tag     => $tag,
                           bh      => $bp,
                           backupdestination => $$bp{backupdestination},
                         }
		);
	}
    }
    #print Dumper \@INCREMENTS;
}

sub list_increments {
    my $bp=$_[0];

    my $c="$RDIFF_BACKUP_BINARY -l --parsable-output ".$$bp{dest};
    debug($c);
    my @res=`$c`;
    #@res == 1 and next; # if there is only one increment, don't consider it for removal
    foreach my $ln (@res) {
      chomp $ln;
      $ln =~ /^(\d+)\sdirectory$/ or next;
      push(@{$$bp{increments}},$1);
    }
}

sub remove_oldest {
    my $backupdest=$_[0];

    unless(@INCREMENTS > 0) {
	build_increment_list();
    }
    foreach my $ih (sort { $$a{inctime} <=> $$b{inctime} } (@INCREMENTS)) {
	debug("remove_oldest: $$ih{inctime}");
	if(defined $$ih{removed} and $$ih{removed}) {
	    debug("cannot remove previously removed increment for $$ih{tag}");
	    next;
	}
	if(scalar @{$$ih{bh}{increments}} == 1) {
	    # cannot remove the only increment!
	    debug("cannot remove only increment for $$ih{tag}");
	    next;
	}
	unless($backupdest eq 'any' or
	       $backupdest eq $$ih{bh}{backupdestination}) {
	    debug("skipping because it isn't in the backupdestination we are looking for: $backupdest $$ih{bh}{backupdestination}");
	    next;
	}
	my $t=$$ih{inctime};
	my @com=($RDIFF_BACKUP_BINARY,
             verbargs($$ih{bh}),
		 '--remove-older-than',($t+1), # do I really need to add 1?
		 $$ih{bh}{dest});
	info(join(" ",@com));
	unless($TEST) {
	    system(@com);
	    unless($? == 0) {
		error("rdiff-backup did not exit cleanly!");
		return 0;
	    }
	}
	$$ih{removed}=1;
#	print Dumper $BACKUPS{$$ih{tag}}{increments};
	shift(@{$$ih{bh}{increments}});
#	print Dumper $BACKUPS{$$ih{tag}}{increments};
	return 1;
    }
}

sub check_space {
    my $bh=$CONFIG{backupdestination}{$_[0]};
    update_bd_space($bh) or return -1;    
    if(defined $$bh{minfree} and $$bh{avail} < $$bh{minfree}) {
	return 0;
    } elsif(defined $$bh{percentused} and $$bh{percent} > $$bh{percentused}) {
	return 0;
    }
    return 1;
}

sub update_bd_space {
    my $bh=$_[0];
    my $com='POSIXLY_CORRECT=1 BLOCKSIZE=512 df -P '.$$bh{path};
    my @a=`$com`;
    unless($? == 0) {
	error("unable to run \"$com\": no further backups will be attempted to this directory");
	$$bh{busted}=1;
	return 0;
    }
    unless($a[1] =~ /(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\%/) {
	error("unable to parse output from \"$com\": no further backups will be attempted to this directory");
	$$bh{busted}=1;
	return 0;
    }
    $$bh{size}=$1;
    $$bh{used}=$2;
    $$bh{avail}=$3;
    $$bh{percent}=$4;
    return 1;
}

sub log_exit_status {
  my($bh,$exit)=@_;
  dlog('notice','exit status',
       {'exit' => $exit},
       $bh);
}

sub stringy {
  # each element passed to stringy should be a HASH REF
  my %a; # strings
  foreach my $h (@_) {
    next unless ref $h eq 'HASH';
    foreach my $key (keys(%$h)) {
      next if ref ${$h}{$key}; # must not be a reference
      my $val=${$h}{$key};
      $val =~ s/\n/NL/g; # remove newlines
      $val =~ s/"/\\"/g; # replace " with \"
      $a{$key}=$val;
    }
  }
  my @f;
  foreach my $key (sort {&sort_tags} (keys(%a))) {
    push(@f,"$key=\"$a{$key}\"");
  }
  return join(" ",@f);
}

sub dlog {
  my $level = shift;
  my $msg   = shift;
  my $time  = time();
  $DISPATCHER->log( level   => $level,
                    message => stringy({'msg'      => $msg,
                                        'severity' => $level,
                                        timestamp  => $time,
                                        datetime   => strftime("%F %T",localtime($time))},
                                       @_),
                  );
}

sub sort_tags {
  return tag_prio($a) <=> tag_prio($b);
}

sub tag_prio {
  my %prios=(
             datetime  => -10,
             severity  => -9,
             msg       => -5,
             timestamp => 50,
             host      => 2,
             tag       => 1,
             backupdestination => 10,
             dest      => 10,
             gtag      => 10,
             btype     => 10,
            );
  my $t=lc $_[0];
  return $prios{$t} if defined $prios{$t};
  return 0;
}


=head1 NAME

rdbduprunner - perl magic wrapper for rsync, rdiff-backup, and duplicity

=head1 SYNOPSIS

B<rdbduprunner> {B<-h|--help>}

B<rdbduprunner> {B<--test>|B<--notest>} {B<--config> I<path>} {B<--dest> I<regex>} {B<--host> I<regex>} {B<--path> I<regex>} {B<--facility> I<user|daemon|...>} {B<--level> I<info|warn|...>} {B<--lockfile> I<path>} {B<--logfile> I<path>} {B<-t|--terminal-verbosity> I<integer>} {B<--verbosity> I<integer>} {B<-v|--verbose>} {B<--progress>}


=head1 DESCRIPTION

rdbduprunner is a wrapper for rsync, rdiff-backup, and duplicity
backups.  By default rdbduprunner will get all it's configuration from
~/.rdbduprunner.rc using an apache-esque config file format parsed by
the Config::General module.

General usage involves running rdbduprunner with no options which will
only print out warnings and the commands that would be invoked if you
were to run it with the --notest option. Then run it again with the
--notest option to see the output.

Other common options involve filtering which backups to run, adjusting
the verbosity of the output, adjusting logging.


=head1 OPTIONS

=over 4

=item {B<--test>|B<--notest>}

The default invocation assumes --test which causes rdbduprunner to
print which commands it would run.  Passing --notest will cause
rdbduprunner to actually run the backup commands.

=item {B<--dest> I<regex>}

This option causes the backups to be run to be filtered based on the
BackupDestination.

=item {B<--host> I<regex>}

This option causes the backups to be run to be filtered based on the
Host.

=item {B<--path> I<regex>}

This option causes the backups to be run to be filtered based on the
path on the host to be backed up.

=item {B<-t|--terminal-verbosity> I<integer>}

Increases logging verbosity to the terminal with
rdiff-backup/duplicity backups.

=item {B<--verbosity> I<integer>}

Increases logging verbosity to the rdiff-backup/duplicity log files.

=item {B<-v|--verbose>}

Rsync specific. Passes -v to rsync invocations.

=item {B<--progress>}

Rsync specific. Passes --progress to rsync invocations.

=back

=head1 RETURN VALUE

=head1 ERRORS

=head1 DIAGNOSTICS

=head1 EXAMPLES

=head1 ENVIRONMENT

=head1 FILES

=head2 F<$HOME/.rdbduprunner.rc>

rdbduprunner's config file is an Apache style config file parsed by
the Config::General perl module. It consists of global options,
options enclosed in a BackupDestination config section and options
enclosed in a BackupSet section.  The options names are case
insensitive. Options are generally honored in this order:

=over 4

=item Command line options

=item BackupSet options

=item BackupDestination options

=item Global options

=back

=head3 Global Options

=over 4

=item I<DuplicityBinary> - path to duplicity

=item I<RdiffBackupBinary> - path to rdiff-backup

=item I<RsyncBinary> - path to rsync

=item I<LockFile> - change the default lock/pid file from
F<$HOME/rdbduprunner.pid>

=item I<ExcludePath> - What directory to look for exclude
files. Defaults to F</etc/rdbduprunner-excludes>

=item I<UseAgent>

=item I<TempDir> - Passed to some binaries as an alternate temp dir
path. Defaults to not pass any temp options therefore probably uses
/tmp.

=item I<DefaultBackupDestination> - Which backup destination to use if
none is specified.

=back

=head3 BackupDestination Options

Items enclosed in a <BackupDestination X> configuration block. The
name of the block is referenced by the I<DefaultBackupDestination> global
option and the I<BackupDestination> config option inside BackupSet
blocks.

=over 4

=back

=head3 BackupSet Options

Items enclosed in a <BackupSet X> configuration block. The
name of the block is not used anywhere but should be unique.

=over 4

=back

=head2 F<$HOME/rdbduprunner.pid>

Default PID/lock file.

=head1 CAVEATS

=head1 BUGS

=head1 RESTRICTIONS

=head1 NOTES

=head1 AUTHOR

Aran Cox <arancox@gmail.com>

=head1 HISTORY

=head1 SEE ALSO

=over 4

rdiff-backup(1), duplicity(1), rsync(1), trickle(1), ssh(1), unison(1).

=back
