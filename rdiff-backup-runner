#! /usr/bin/perl

# $Id: rdiff-backup-runner,v 1.19 2008/02/25 19:41:19 acox Exp $

use strict;
use warnings;
use Getopt::Long;
use logentry;
use File::Temp qw( mkdtemp mkstemp );
use Data::Dumper;
use Fcntl qw(:DEFAULT :flock); # import LOCK_* constants
use Env qw( HOME );

our $TEST=1;
our $VERBOSITY=5;
our $TVERBOSITY=3;
our $LOCALHOST;
our $COMPARE=0;
our $RDIFF_BACKUP='rdiff-backup'; # assume it's in the path
our $BACKUP_ROOT='/mnt/backup/rdiff-backup';
our $EXCLUDE_PATH='/etc/rdiff-backup';
our $PATH;
our $HOST;
our $FORCE=0;
our $REMOVE;
our %BACKUPS;
our %INCREMENTS;
our ($VERBOSE,$DEBUG);
our $AVERAGE;
our ($IFILES,$IFILESIZE,$DESTSIZECHANGE);
our $SNAPPV='/dev/md0';
our $SNAPSIZE='1G';
our $LISTOLDEST=0;
our $FREE;
our $CHECK=0;
our $CLEANUP=0;
our $DEFMAXINC;
our $DEFMAXAGE;

our $CONFIG="$HOME/.rbrrc";

GetOptions('test!'          => \$TEST,
           'verbosity=i'    => \$VERBOSITY,
           'v|terminal-verbosity=i' => \$TVERBOSITY,
           'localhost=s'    => \$LOCALHOST,
           'rdiff-backup=s' => \$RDIFF_BACKUP,
           'backup-root=s'  => \$BACKUP_ROOT,
           'compare'        => \$COMPARE,
           'path=s'         => \$PATH,
           'host=s'         => \$HOST,
           'force!'         => \$FORCE,
           'remove-oldest!' => \$REMOVE,
           'verbose!'       => \$VERBOSE,
           'debug!'         => \$DEBUG,
           'average'        => \$AVERAGE,
           'snappv=s'       => \$SNAPPV,
           'list-oldest'    => \$LISTOLDEST,
	   'free=s'         => \$FREE,
	   'check'          => \$CHECK, # perform a check-destination-dir on target
	   'config=s'       => \$CONFIG, # config file
	   'cleanup'        => \$CLEANUP,
	   'maxinc=i'       => \$DEFMAXINC,
	   'maxage=s'       => \$DEFMAXAGE,
          );

if(not defined $LOCALHOST) {
  $LOCALHOST=`hostname`;
  chomp $LOCALHOST;
  my @a=split(/\./,$LOCALHOST);
  @a > 1 and $LOCALHOST=$a[0];
}

our @BACKUPS;
require $CONFIG or die "unable to parse the rdiff-backup-runner config file: $CONFIG";

logentry::OpenLog('local5','rdiff-backup-runner');
logentry('info','starting');

foreach my $bh (@BACKUPS) {
  my $host=(defined $$bh{host} ? $$bh{host} : $LOCALHOST);
  my $path=(defined $$bh{path} ? $$bh{path} : '/');
  my $sshcompress=(defined $$bh{compress} ? $$bh{compress} : 0);
  my $dest;
  my $tag;
  if(defined $$bh{dest}) {
    $dest=$$bh{dest};
    $tag=$dest;
  } else {
    $dest=$path;
    $dest =~ s/\//\-/g;
    $dest eq '-' and $dest='-root';
    $tag=$host.$dest;
  }

  unless(defined $$bh{root}) {
    $$bh{root}=$BACKUP_ROOT;
  }
  $dest=$$bh{root}.'/'.$tag;

  if(defined $PATH and $path !~ /$PATH/) {
    next;
  }
  if(defined $HOST and $host !~ /$HOST/) {
    next;
  }

  logentry('info',"$host $path $tag $dest");

  $BACKUPS{$tag}=$bh;
  $BACKUPS{$tag}{dest}=$dest;
  $BACKUPS{$tag}{path}=$path;
  $BACKUPS{$tag}{tag}=$tag;
  $BACKUPS{$tag}{host}=$host;
  
  $BACKUPS{$tag}{sshcompress}=$sshcompress;

  if($BACKUPS{$tag}{path} =~ /(home|home\/acox|home\/spin\/Maildir)$/) {
      #push(@com,'--exclude-globbing-filelist',
      #     $EXCLUDE_PATH.'/exclude-generic-home');
      push(@{$BACKUPS{$tag}{excludes}},$EXCLUDE_PATH.'/exclude-generic-home');
  }
  push(@{$BACKUPS{$tag}{excludes}},
       $EXCLUDE_PATH.'/exclude-'.$tag);
  #push(@com,'--exclude-globbing-filelist',
  #     $EXCLUDE_PATH.'/exclude-'.$tag);
  
  if(not defined $BACKUPS{$tag}{maxage} and
     defined $DEFMAXAGE) {
      $BACKUPS{$tag}{maxage}=$DEFMAXAGE;
  }

}

foreach my $tag (sort backup_sort (keys(%BACKUPS))) {
    my $bh=$BACKUPS{$tag}; # for convenience of typing


  if(defined $AVERAGE) {
    my $c="rdiff-backup --calculate-average $BACKUPS{$tag}{dest}/rdiff-backup-data/session_statistics.*.data";
    logentry('debug',$c);
    my @res=`$c`;
    #print @res;
    foreach my $ln (@res) {
      chomp $ln;
      $ln =~ /IncrementFiles\s+(.+?)$/ and $IFILES+=int($1);
      $ln =~ /IncrementFileSize\s+(.+?)\s+/ and $IFILESIZE+=($1/1024/1024);
      $ln =~ /TotalDestinationSizeChange\s+(.+?)\s+/ and $DESTSIZECHANGE+=($1/1024/1024);
    }
  } elsif(defined $REMOVE or $LISTOLDEST or $CLEANUP) {
      unless(-d $BACKUPS{$tag}{dest}) {
	  # skip non-existant destination directories
	  next;
      }
      my $c="rdiff-backup -l --parsable-output ".$BACKUPS{$tag}{dest};
      logentry('debug',$c);
      my @res=`$c`;
      #@res == 1 and next; # if there is only one increment, don't consider it for removal
      foreach my $ln (@res) {
	  chomp $ln;
	  $ln =~ /^(\d+)\sdirectory$/ or next;
	  if(exists $INCREMENTS{$1}) {
	      # this needs fixed... it doesn't really work!
	      $INCREMENTS{$1+.1}=$BACKUPS{$tag};
	      #print Dumper $INCREMENTS{$1};
	      #warn "conflict: $1 $tag $BACKUPS{$tag}{dest}";
	  }
	  $INCREMENTS{$1}=$BACKUPS{$tag};
	  push(@{$BACKUPS{$tag}{increments}},$1);
      }
  } else { # actually do a  backup
      my @com;
      if($$bh{disabled}) {
	  # skip disabled backups
	  next;
      }
      @com=($RDIFF_BACKUP,
	    '--verbosity',$VERBOSITY,
	    '--terminal-verbosity',$TVERBOSITY,
	    '--exclude-special-files',
	    '--exclude-other-filesystems',
	  );
      $BACKUPS{$tag}{sshcompress} or push(@com,'--ssh-no-compression');
      $VERBOSE and push(@com,'--print-statistics');


      
      if($COMPARE) {
	  push(@com,'--compare');
      }

      my $TMPDIR;
      my ($EXH, $EXF);
      my $VGDEV;
      if($BACKUPS{$tag}{host} eq $LOCALHOST and defined $$bh{lvdev}) {
	  my $scom='';
	  $TMPDIR = mkdtemp( '/mnt/rdrXXXXXX' );
	  print $TMPDIR."\n";
	  $VGDEV=$$bh{lvdev};
	  $VGDEV =~ s/\/[a-zA-Z0-9_\-]+$//;
	  unless($TEST) {
	      $scom="lvcreate -s -L $SNAPSIZE -n rdr $$bh{lvdev} $SNAPPV";
	      logentry('info',$scom);
	      system($scom);
	      unless($? == 0) {
		  logentry('crit',
			   "unable to create snapshot for $$bh{lvdev} with size $SNAPSIZE".
			   (defined $SNAPPV and length $SNAPPV > 0 ? " on $SNAPPV" : ''));
		  next;
	      }
	      $scom="mount -o ro $VGDEV/rdr $TMPDIR";
	      logentry('info',$scom);
	      system($scom);
	      unless($? == 0) {
		  logentry('crit',
			   "unable to mount -o ro $VGDEV/rdr $TMPDIR");
		  $scom="lvremove -f $VGDEV/rdr";
		  logentry('info',$scom);
		  unless($? == 0) {
		      logentry('crit',
			       "unable to remove lv snapshot $VGDEV/rdr");
		  }
		  next;
	      }
	  }
	  ($EXH,$EXF) = mkstemp( "/tmp/tmpfilerdrXXXXX" );
	  foreach my $f (@{$BACKUPS{$tag}{excludes}}) {
	      unless(open(IF,$f)) {
		  logentry('warn',"unabled to open $f");
		  next;
	      }
	      while(<IF>) {
		  s/$BACKUPS{$tag}{path}/$TMPDIR/;
		  print $EXH $_;
	      }
	  }
	  close $EXH;
	  push(@com,'--exclude-globbing-filelist',
	       $EXF);
	  
	  push(@com,$TMPDIR,$BACKUPS{$tag}{dest});
      } else {
	  foreach my $f (@{$BACKUPS{$tag}{excludes}}) {
	      push(@com,'--exclude-globbing-filelist',
		   $f);
	  }
	  # this is fugly:
	  push(@com,($BACKUPS{$tag}{host} eq $LOCALHOST ? $BACKUPS{$tag}{path} : $BACKUPS{$tag}{host}.'::'.$BACKUPS{$tag}{path}),$BACKUPS{$tag}{dest});
      }
      logentry('info',join(" ",@com));

      unless($TEST) {
	  my $LOCK_FILE="$HOME/rdiff-backup-runner.pid";
	  unless(open(LOCK,'+<'.$LOCK_FILE) or open(LOCK,'>'.$LOCK_FILE)) {
	      logentry('err',"unable to open pid file: $LOCK_FILE for writing");
	      next;
	  }
	  unless(flock(LOCK,LOCK_EX|LOCK_NB)) {
	      logentry('err',"unable to flock the pid file: $LOCK_FILE");
	      next;
	  }
	  truncate(LOCK,0); # this shouldn't fail if we have the file opened and locked!
	  print LOCK $$."\n"; # who really cares if this fails?

	  if($CHECK) {
	      @com=($RDIFF_BACKUP,
		    '--verbosity',$VERBOSITY,
		    '--terminal-verbosity',$TVERBOSITY,
		    '--check-destination-dir',$BACKUPS{$tag}{dest});
	      logentry('info',join(" ",@com));
	  } else {
	      if ($BACKUPS{$tag}{host} ne $LOCALHOST) {
		  system("/usr/sbin/fping -q $BACKUPS{$tag}{host}");
		  unless($? == 0) {
		      logentry('warning',"fping failed to ping $BACKUPS{$tag}{host}");
		      next;
		  }
	      }
	      if (defined $$bh{prerun}) {
		  print $$bh{prerun}."\n";
		  system($$bh{prerun});
		  unless($? == 0) {
		      logentry('err',"unable to execute prerun command: skipping backup!");
		      next;
		  }
	      }
	  }
	  system(@com);
	  my $mainret=$?;
	  unless($mainret == 0) {
	      logentry('err',"unable to execute rdiff-backup!");
	  }
	  unless($CHECK) {
	      if(defined $$bh{postrun}) {
		  print $$bh{postrun}."\n";
		  system($$bh{postrun});
		  unless($? == 0) {
		      logentry('err',"unable to execute postrun command");
		  }
	      }
	  }
	  if($BACKUPS{$tag}{host} eq $LOCALHOST and defined $$bh{lvdev}) {
	      my $scom="umount $TMPDIR";
	      logentry('info',$scom);
	      system($scom);
	      unless($? == 0) {
		  logentry('err',"unable to umount $TMPDIR");
	      } else {
		  $scom="lvremove -f $VGDEV/rdr";
		  logentry('info',$scom);
		  system($scom);
		  unless($? == 0) {
		      logentry('err',"unable to lvremove $VGDEV/rdr");
		  }
	      }
	      if( defined $TMPDIR and -d $TMPDIR ) {
		  rmdir($TMPDIR);
	      }
	  }
	  if( defined $EXF and -f $EXF ) {
	      unlink($EXF);
	  }
	  unlink $LOCK_FILE;
	  flock(LOCK,LOCK_UN);
	  close LOCK;
      }
  }
}

if(defined $AVERAGE) {
  printf("IncrementFiles: %d\nIncrementFileSize: %.2f MiB\nTotalDestinationSizeChange: %.2f MiB\n",
	 $IFILES,$IFILESIZE,
	 $DESTSIZECHANGE);
}

if(defined $REMOVE) {
  foreach my $t (sort { $a <=> $b } (keys(%INCREMENTS))) {
    if(scalar @{$INCREMENTS{$t}{increments}} == 1) {
	# cannot remove the only increment!
	next;
    }
    logentry('debug',"$t $INCREMENTS{$t}{dest} $INCREMENTS{$t}{tag}");
    my @com=($RDIFF_BACKUP,
	     '--verbosity',$VERBOSITY,
	     '--terminal-verbosity',$TVERBOSITY,
	     '--remove-older-than',($t+1),
	     $INCREMENTS{$t}{dest});
    logentry('info',join(" ",@com));
    unless($TEST) {
      system(@com);
      unless($? == 0) {
	logentry('err',"unable to execute rdiff-backup!");
      }
    }
    last;
  }
}

if($LISTOLDEST) {
  foreach my $t (sort { $a <=> $b } (keys(%INCREMENTS))) {
    logentry('info',localtime($t).' '.$INCREMENTS{$t}{dest}.' '.$INCREMENTS{$t}{tag});
  }
}


if($CLEANUP) {
    my $now=time();
    foreach my $tag (sort(keys(%BACKUPS))) {
	if(defined $BACKUPS{$tag}{maxinc} and
	   $BACKUPS{$tag}{maxinc} =~ /^\d+$/ and
	   @{$BACKUPS{$tag}{increments}} > $BACKUPS{$tag}{maxinc} ) {
	    # too many!
	    logentry('info',"$tag\t Incs: ".
		     scalar @{$BACKUPS{$tag}{increments}}.
		     "\t Max: ".$BACKUPS{$tag}{maxinc});
	    my $lastinc=(sort {$a <=> $b} (@{$BACKUPS{$tag}{increments}}))[$BACKUPS{$tag}{maxinc}-1];
	    logentry('debug',"last time to keep for $tag: ".localtime($lastinc));
	    my @com=($RDIFF_BACKUP,
		     '--verbosity',$VERBOSITY,
		     '--terminal-verbosity',$TVERBOSITY,
		     '--remove-older-than',$lastinc,
		     '--force',
		     $BACKUPS{$tag}{dest},
		);
	    logentry('info',join(" ",@com));
	    unless($TEST) {
		system(@com);
		unless($? == 0) {
		    logentry('err',"unable to execute rdiff-backup!");
		}
	    }
	}
	if(defined $BACKUPS{$tag}{maxage} and
	   $BACKUPS{$tag}{maxage} =~ /^\d/) {
	    my @com=($RDIFF_BACKUP,
		     '--verbosity',$VERBOSITY,
		     '--terminal-verbosity',$TVERBOSITY,
		     '--remove-older-than',$BACKUPS{$tag}{maxage},
		     '--force',
		     $BACKUPS{$tag}{dest},
		);
	    logentry('info',join(" ",@com));
	    unless($TEST) {
		system(@com);
		unless($? == 0) {
		    logentry('err',"unable to execute rdiff-backup!");
		}
	    }
	    
	}
    }
}


sub backup_sort {
    my $aprio=(defined $BACKUPS{$a}{priority} ? $BACKUPS{$a}{priority} : 0);
    my $bprio=(defined $BACKUPS{$b}{priority} ? $BACKUPS{$b}{priority} : 0);
    my $ahost=(defined $BACKUPS{$a}{host} ? $BACKUPS{$a}{host} : $LOCALHOST);
    my $bhost=(defined $BACKUPS{$b}{host} ? $BACKUPS{$b}{host} : $LOCALHOST);

    if($aprio == $bprio and $ahost eq $bhost) {
	return $BACKUPS{$a}{path} cmp $BACKUPS{$b}{path};
    } elsif($aprio == $bprio) {
	return $ahost cmp $bhost;
    } # else, compare the prio
    return $aprio <=> $bprio;
}

#sub find_backup_by_tag {
#    foreach my $hr (@BACKUPS) {
#	if
